0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 int             cpuid(void);
0358 void            exit(void);
0359 int             fork(void);
0360 int             growproc(int);
0361 int             kill(int);
0362 struct cpu*     mycpu(void);
0363 struct proc*    myproc();
0364 void            update_times(struct proc*);
0365 void            add_to_queue(struct proc*, int);
0366 void            pop_queue(int);
0367 void            remove_from_queue(struct proc*);
0368 void            clean_queue(int);
0369 void            pinit(void);
0370 void            procdump(void);
0371 void            scheduler(void) __attribute__((noreturn));
0372 void            sched(void);
0373 void            setproc(struct proc*);
0374 void            sleep(void*, struct spinlock*);
0375 void            userinit(void);
0376 int             wait(void);
0377 int             waitx(int*, int*);
0378 int             setpriority(int);
0379 void            update_rtime(void);
0380 void            wakeup(void*);
0381 void            yield(void);
0382 
0383 
0384 void            swtch(struct context**, struct context*);
0385 
0386 
0387 void            acquire(struct spinlock*);
0388 void            getcallerpcs(void*, uint*);
0389 int             holding(struct spinlock*);
0390 void            initlock(struct spinlock*, char*);
0391 void            release(struct spinlock*);
0392 void            pushcli(void);
0393 void            popcli(void);
0394 
0395 
0396 void            acquiresleep(struct sleeplock*);
0397 void            releasesleep(struct sleeplock*);
0398 int             holdingsleep(struct sleeplock*);
0399 void            initsleeplock(struct sleeplock*, char*);
0400 
0401 int             memcmp(const void*, const void*, uint);
0402 void*           memmove(void*, const void*, uint);
0403 void*           memset(void*, int, uint);
0404 char*           safestrcpy(char*, const char*, int);
0405 int             strlen(const char*);
0406 int             strncmp(const char*, const char*, uint);
0407 char*           strncpy(char*, const char*, int);
0408 
0409 
0410 int             argint(int, int*);
0411 int             argptr(int, char**, int);
0412 int             argstr(int, char**);
0413 int             fetchint(uint, int*);
0414 int             fetchstr(uint, char**);
0415 void            syscall(void);
0416 
0417 
0418 void            timerinit(void);
0419 
0420 
0421 void            idtinit(void);
0422 extern uint     ticks;
0423 void            tvinit(void);
0424 extern struct spinlock tickslock;
0425 
0426 
0427 void            uartinit(void);
0428 void            uartintr(void);
0429 void            uartputc(int);
0430 
0431 
0432 void            seginit(void);
0433 void            kvmalloc(void);
0434 pde_t*          setupkvm(void);
0435 char*           uva2ka(pde_t*, char*);
0436 int             allocuvm(pde_t*, uint, uint);
0437 int             deallocuvm(pde_t*, uint, uint);
0438 void            freevm(pde_t*);
0439 void            inituvm(pde_t*, char*, uint);
0440 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0441 pde_t*          copyuvm(pde_t*, uint);
0442 void            switchuvm(struct proc*);
0443 void            switchkvm(void);
0444 int             copyout(pde_t*, uint, void*, uint);
0445 void            clearpteu(pde_t *pgdir, char *uva);
0446 
0447 
0448 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_W     0x2       
0667 #define STA_R     0x2       
0668 
0669 
0670 
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_IF           0x00000200      
0705 
0706 
0707 #define CR0_PE          0x00000001      
0708 #define CR0_WP          0x00010000      
0709 #define CR0_PG          0x80000000      
0710 
0711 #define CR4_PSE         0x00000010      
0712 
0713 
0714 #define SEG_KCODE 1  
0715 #define SEG_KDATA 2  
0716 #define SEG_UCODE 3  
0717 #define SEG_UDATA 4  
0718 #define SEG_TSS   5  
0719 
0720 
0721 #define NSEGS     6
0722 
0723 #ifndef __ASSEMBLER__
0724 
0725 struct segdesc {
0726   uint lim_15_0 : 16;  
0727   uint base_15_0 : 16; 
0728   uint base_23_16 : 8; 
0729   uint type : 4;       
0730   uint s : 1;          
0731   uint dpl : 2;        
0732   uint p : 1;          
0733   uint lim_19_16 : 4;  
0734   uint avl : 1;        
0735   uint rsv1 : 1;       
0736   uint db : 1;         
0737   uint g : 1;          
0738   uint base_31_24 : 8; 
0739 };
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0752 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0753   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0754   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0755 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0756 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0757   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0758   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0759 #endif
0760 
0761 #define DPL_USER    0x3     
0762 
0763 
0764 #define STA_X       0x8     
0765 #define STA_W       0x2     
0766 #define STA_R       0x2     
0767 
0768 
0769 #define STS_T32A    0x9     
0770 #define STS_IG32    0xE     
0771 #define STS_TG32    0xF     
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0783 
0784 
0785 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0786 
0787 
0788 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0789 
0790 
0791 #define NPDENTRIES      1024    
0792 #define NPTENTRIES      1024    
0793 #define PGSIZE          4096    
0794 
0795 #define PTXSHIFT        12      
0796 #define PDXSHIFT        22      
0797 
0798 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0799 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0800 
0801 #define PTE_P           0x001   
0802 #define PTE_W           0x002   
0803 #define PTE_U           0x004   
0804 #define PTE_PS          0x080   
0805 
0806 
0807 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0808 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0809 
0810 #ifndef __ASSEMBLER__
0811 typedef uint pte_t;
0812 
0813 
0814 struct taskstate {
0815   uint link;         
0816   uint esp0;         
0817   ushort ss0;        
0818   ushort padding1;
0819   uint *esp1;
0820   ushort ss1;
0821   ushort padding2;
0822   uint *esp2;
0823   ushort ss2;
0824   ushort padding3;
0825   void *cr3;         
0826   uint *eip;         
0827   uint eflags;
0828   uint eax;          
0829   uint ecx;
0830   uint edx;
0831   uint ebx;
0832   uint *esp;
0833   uint *ebp;
0834   uint esi;
0835   uint edi;
0836   ushort es;         
0837   ushort padding4;
0838   ushort cs;
0839   ushort padding5;
0840   ushort ss;
0841   ushort padding6;
0842   ushort ds;
0843   ushort padding7;
0844   ushort fs;
0845   ushort padding8;
0846   ushort gs;
0847   ushort padding9;
0848   ushort ldt;
0849   ushort padding10;
0850   ushort t;          
0851   ushort iomb;       
0852 };
0853 
0854 
0855 struct gatedesc {
0856   uint off_15_0 : 16;   
0857   uint cs : 16;         
0858   uint args : 5;        
0859   uint rsv1 : 3;        
0860   uint type : 4;        
0861   uint s : 1;           
0862   uint dpl : 2;         
0863   uint p : 1;           
0864   uint off_31_16 : 16;  
0865 };
0866 
0867 
0868 
0869 
0870 
0871 
0872 
0873 
0874 
0875 #define SETGATE(gate, istrap, sel, off, d)                \
0876 {                                                         \
0877   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0878   (gate).cs = (sel);                                      \
0879   (gate).args = 0;                                        \
0880   (gate).rsv1 = 0;                                        \
0881   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0882   (gate).s = 0;                                           \
0883   (gate).dpl = (d);                                       \
0884   (gate).p = 1;                                           \
0885   (gate).off_31_16 = (uint)(off) >> 16;                  \
0886 }
0887 
0888 #endif
0889 
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 
0902 #define ELF_MAGIC 0x464C457FU  
0903 
0904 
0905 struct elfhdr {
0906   uint magic;  
0907   uchar elf[12];
0908   ushort type;
0909   ushort machine;
0910   uint version;
0911   uint entry;
0912   uint phoff;
0913   uint shoff;
0914   uint flags;
0915   ushort ehsize;
0916   ushort phentsize;
0917   ushort phnum;
0918   ushort shentsize;
0919   ushort shnum;
0920   ushort shstrndx;
0921 };
0922 
0923 
0924 struct proghdr {
0925   uint type;
0926   uint off;
0927   uint vaddr;
0928   uint paddr;
0929   uint filesz;
0930   uint memsz;
0931   uint flags;
0932   uint align;
0933 };
0934 
0935 
0936 #define ELF_PROG_LOAD           1
0937 
0938 
0939 #define ELF_PROG_FLAG_EXEC      1
0940 #define ELF_PROG_FLAG_WRITE     2
0941 #define ELF_PROG_FLAG_READ      4
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 struct rtcdate {
0951   uint second;
0952   uint minute;
0953   uint hour;
0954   uint day;
0955   uint month;
0956   uint year;
0957 };
0958 
0959 
0960 
0961 
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 
0972 
0973 
0974 
0975 
0976 
0977 
0978 
0979 
0980 
0981 
0982 
0983 
0984 
0985 
0986 
0987 
0988 
0989 
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 
1043 .globl entry
1044 entry:
1045   
1046   movl    %cr4, %eax
1047   orl     $(CR4_PSE), %eax
1048   movl    %eax, %cr4
1049   
1050   movl    $(V2P_WO(entrypgdir)), %eax
1051   movl    %eax, %cr3
1052   
1053   movl    %cr0, %eax
1054   orl     $(CR0_PG|CR0_WP), %eax
1055   movl    %eax, %cr0
1056 
1057   
1058   movl $(stack + KSTACKSIZE), %esp
1059 
1060   
1061   
1062   
1063   
1064   mov $main, %eax
1065   jmp *%eax
1066 
1067 .comm stack, KSTACKSIZE
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 .code32  
1146 start32:
1147   
1148   movw    $(SEG_KDATA<<3), %ax    
1149   movw    %ax, %ds                
1150   movw    %ax, %es                
1151   movw    %ax, %ss                
1152   movw    $0, %ax                 
1153   movw    %ax, %fs                
1154   movw    %ax, %gs                
1155 
1156   
1157   movl    %cr4, %eax
1158   orl     $(CR4_PSE), %eax
1159   movl    %eax, %cr4
1160   
1161   movl    (start-12), %eax
1162   movl    %eax, %cr3
1163   
1164   movl    %cr0, %eax
1165   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1166   movl    %eax, %cr0
1167 
1168   
1169   movl    (start-4), %esp
1170   
1171   call	 *(start-8)
1172 
1173   movw    $0x8a00, %ax
1174   movw    %ax, %dx
1175   outw    %ax, %dx
1176   movw    $0x8ae0, %ax
1177   outw    %ax, %dx
1178 spin:
1179   jmp     spin
1180 
1181 .p2align 2
1182 gdt:
1183   SEG_NULLASM
1184   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1185   SEG_ASM(STA_W, 0, 0xffffffff)
1186 
1187 
1188 gdtdesc:
1189   .word   (gdtdesc - gdt - 1)
1190   .long   gdt
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();     
1223   seginit();       
1224   picinit();       
1225   ioapicinit();    
1226   consoleinit();   
1227   uartinit();      
1228   pinit();         
1229   tvinit();        
1230   binit();         
1231   fileinit();      
1232   ideinit();       
1233   startothers();   
1234   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1235   userinit();      
1236   mpmain();        
1237 }
1238 
1239 
1240 static void
1241 mpenter(void)
1242 {
1243   switchkvm();
1244   seginit();
1245   lapicinit();
1246   mpmain();
1247 }
1248 
1249 
1250 
1251 static void
1252 mpmain(void)
1253 {
1254   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1255   idtinit();       
1256   xchg(&(mycpu()->started), 1); 
1257   scheduler();     
1258 }
1259 
1260 pde_t entrypgdir[];  
1261 
1262 
1263 static void
1264 startothers(void)
1265 {
1266   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1267   uchar *code;
1268   struct cpu *c;
1269   char *stack;
1270 
1271   
1272   
1273   
1274   code = P2V(0x7000);
1275   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1276 
1277   for(c = cpus; c < cpus+ncpu; c++){
1278     if(c == mycpu())  
1279       continue;
1280 
1281     
1282     
1283     
1284     stack = kalloc();
1285     *(void**)(code-4) = stack + KSTACKSIZE;
1286     *(void(**)(void))(code-8) = mpenter;
1287     *(int**)(code-12) = (void *) V2P(entrypgdir);
1288 
1289     lapicstartap(c->apicid, V2P(code));
1290 
1291     
1292     while(c->started == 0)
1293       ;
1294   }
1295 }
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 __attribute__((__aligned__(PGSIZE)))
1306 pde_t entrypgdir[NPDENTRIES] = {
1307   
1308   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1309   
1310   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1311 };
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 struct spinlock {
1352   uint locked;       
1353 
1354   
1355   char *name;        
1356   struct cpu *cpu;   
1357   uint pcs[10];      
1358                      
1359 };
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 #include "types.h"
1403 #include "defs.h"
1404 #include "param.h"
1405 #include "x86.h"
1406 #include "memlayout.h"
1407 #include "mmu.h"
1408 #include "proc.h"
1409 #include "spinlock.h"
1410 
1411 void
1412 initlock(struct spinlock *lk, char *name)
1413 {
1414   lk->name = name;
1415   lk->locked = 0;
1416   lk->cpu = 0;
1417 }
1418 
1419 
1420 
1421 
1422 
1423 void
1424 acquire(struct spinlock *lk)
1425 {
1426   pushcli(); 
1427   if(holding(lk))
1428     panic("acquire");
1429 
1430   
1431   while(xchg(&lk->locked, 1) != 0)
1432     ;
1433 
1434   
1435   
1436   
1437   __sync_synchronize();
1438 
1439   
1440   lk->cpu = mycpu();
1441   getcallerpcs(&lk, lk->pcs);
1442 }
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 void
1452 release(struct spinlock *lk)
1453 {
1454   if(!holding(lk))
1455     panic("release");
1456 
1457   lk->pcs[0] = 0;
1458   lk->cpu = 0;
1459 
1460   
1461   
1462   
1463   
1464   
1465   __sync_synchronize();
1466 
1467   
1468   
1469   
1470   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1471 
1472   popcli();
1473 }
1474 
1475 
1476 void
1477 getcallerpcs(void *v, uint pcs[])
1478 {
1479   uint *ebp;
1480   int i;
1481 
1482   ebp = (uint*)v - 2;
1483   for(i = 0; i < 10; i++){
1484     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1485       break;
1486     pcs[i] = ebp[1];     
1487     ebp = (uint*)ebp[0]; 
1488   }
1489   for(; i < 10; i++)
1490     pcs[i] = 0;
1491 }
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 int
1502 holding(struct spinlock *lock)
1503 {
1504   int r;
1505   pushcli();
1506   r = lock->locked && lock->cpu == mycpu();
1507   popcli();
1508   return r;
1509 }
1510 
1511 
1512 
1513 
1514 
1515 
1516 void
1517 pushcli(void)
1518 {
1519   int eflags;
1520 
1521   eflags = readeflags();
1522   cli();
1523   if(mycpu()->ncli == 0)
1524     mycpu()->intena = eflags & FL_IF;
1525   mycpu()->ncli += 1;
1526 }
1527 
1528 void
1529 popcli(void)
1530 {
1531   if(readeflags()&FL_IF)
1532     panic("popcli - interruptible");
1533   if(--mycpu()->ncli < 0)
1534     panic("popcli");
1535   if(mycpu()->ncli == 0 && mycpu()->intena)
1536     sti();
1537 }
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 #include "param.h"
1551 #include "types.h"
1552 #include "defs.h"
1553 #include "x86.h"
1554 #include "memlayout.h"
1555 #include "mmu.h"
1556 #include "proc.h"
1557 #include "elf.h"
1558 
1559 extern char data[];  
1560 pde_t *kpgdir;  
1561 
1562 
1563 
1564 void
1565 seginit(void)
1566 {
1567   struct cpu *c;
1568 
1569   
1570   
1571   
1572   
1573   c = &cpus[cpuid()];
1574   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1575   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1576   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1577   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1578   lgdt(c->gdt, sizeof(c->gdt));
1579 }
1580 
1581 
1582 
1583 
1584 static pte_t *
1585 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1586 {
1587   pde_t *pde;
1588   pte_t *pgtab;
1589 
1590   pde = &pgdir[PDX(va)];
1591   if(*pde & PTE_P){
1592     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1593   } else {
1594     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1595       return 0;
1596     
1597     memset(pgtab, 0, PGSIZE);
1598     
1599     
1600     
1601     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1602   }
1603   return &pgtab[PTX(va)];
1604 }
1605 
1606 
1607 
1608 
1609 static int
1610 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1611 {
1612   char *a, *last;
1613   pte_t *pte;
1614 
1615   a = (char*)PGROUNDDOWN((uint)va);
1616   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1617   for(;;){
1618     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1619       return -1;
1620     if(*pte & PTE_P)
1621       panic("remap");
1622     *pte = pa | perm | PTE_P;
1623     if(a == last)
1624       break;
1625     a += PGSIZE;
1626     pa += PGSIZE;
1627   }
1628   return 0;
1629 }
1630 
1631 
1632 
1633 
1634 
1635 
1636 
1637 
1638 
1639 
1640 
1641 
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 
1652 
1653 
1654 static struct kmap {
1655   void *virt;
1656   uint phys_start;
1657   uint phys_end;
1658   int perm;
1659 } kmap[] = {
1660  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1661  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1662  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1663  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1664 };
1665 
1666 
1667 pde_t*
1668 setupkvm(void)
1669 {
1670   pde_t *pgdir;
1671   struct kmap *k;
1672 
1673   if((pgdir = (pde_t*)kalloc()) == 0)
1674     return 0;
1675   memset(pgdir, 0, PGSIZE);
1676   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1677     panic("PHYSTOP too high");
1678   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1679     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1680                 (uint)k->phys_start, k->perm) < 0) {
1681       freevm(pgdir);
1682       return 0;
1683     }
1684   return pgdir;
1685 }
1686 
1687 
1688 
1689 void
1690 kvmalloc(void)
1691 {
1692   kpgdir = setupkvm();
1693   switchkvm();
1694 }
1695 
1696 
1697 
1698 
1699 
1700 
1701 
1702 void
1703 switchkvm(void)
1704 {
1705   lcr3(V2P(kpgdir));   
1706 }
1707 
1708 
1709 void
1710 switchuvm(struct proc *p)
1711 {
1712   if(p == 0)
1713     panic("switchuvm: no process");
1714   if(p->kstack == 0)
1715     panic("switchuvm: no kstack");
1716   if(p->pgdir == 0)
1717     panic("switchuvm: no pgdir");
1718 
1719   pushcli();
1720   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1721                                 sizeof(mycpu()->ts)-1, 0);
1722   mycpu()->gdt[SEG_TSS].s = 0;
1723   mycpu()->ts.ss0 = SEG_KDATA << 3;
1724   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1725   
1726   
1727   mycpu()->ts.iomb = (ushort) 0xFFFF;
1728   ltr(SEG_TSS << 3);
1729   lcr3(V2P(p->pgdir));  
1730   popcli();
1731 }
1732 
1733 
1734 
1735 void
1736 inituvm(pde_t *pgdir, char *init, uint sz)
1737 {
1738   char *mem;
1739 
1740   if(sz >= PGSIZE)
1741     panic("inituvm: more than a page");
1742   mem = kalloc();
1743   memset(mem, 0, PGSIZE);
1744   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1745   memmove(mem, init, sz);
1746 }
1747 
1748 
1749 
1750 
1751 
1752 int
1753 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1754 {
1755   uint i, pa, n;
1756   pte_t *pte;
1757 
1758   if((uint) addr % PGSIZE != 0)
1759     panic("loaduvm: addr must be page aligned");
1760   for(i = 0; i < sz; i += PGSIZE){
1761     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1762       panic("loaduvm: address should exist");
1763     pa = PTE_ADDR(*pte);
1764     if(sz - i < PGSIZE)
1765       n = sz - i;
1766     else
1767       n = PGSIZE;
1768     if(readi(ip, P2V(pa), offset+i, n) != n)
1769       return -1;
1770   }
1771   return 0;
1772 }
1773 
1774 
1775 
1776 int
1777 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1778 {
1779   char *mem;
1780   uint a;
1781 
1782   if(newsz >= KERNBASE)
1783     return 0;
1784   if(newsz < oldsz)
1785     return oldsz;
1786 
1787   a = PGROUNDUP(oldsz);
1788   for(; a < newsz; a += PGSIZE){
1789     mem = kalloc();
1790     if(mem == 0){
1791       cprintf("allocuvm out of memory\n");
1792       deallocuvm(pgdir, newsz, oldsz);
1793       return 0;
1794     }
1795     memset(mem, 0, PGSIZE);
1796     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1797       cprintf("allocuvm out of memory (2)\n");
1798       deallocuvm(pgdir, newsz, oldsz);
1799       kfree(mem);
1800       return 0;
1801     }
1802   }
1803   return newsz;
1804 }
1805 
1806 
1807 
1808 
1809 
1810 int
1811 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1812 {
1813   pte_t *pte;
1814   uint a, pa;
1815 
1816   if(newsz >= oldsz)
1817     return oldsz;
1818 
1819   a = PGROUNDUP(newsz);
1820   for(; a  < oldsz; a += PGSIZE){
1821     pte = walkpgdir(pgdir, (char*)a, 0);
1822     if(!pte)
1823       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
1824     else if((*pte & PTE_P) != 0){
1825       pa = PTE_ADDR(*pte);
1826       if(pa == 0)
1827         panic("kfree");
1828       char *v = P2V(pa);
1829       kfree(v);
1830       *pte = 0;
1831     }
1832   }
1833   return newsz;
1834 }
1835 
1836 
1837 
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 void
1853 freevm(pde_t *pgdir)
1854 {
1855   uint i;
1856 
1857   if(pgdir == 0)
1858     panic("freevm: no pgdir");
1859   deallocuvm(pgdir, KERNBASE, 0);
1860   for(i = 0; i < NPDENTRIES; i++){
1861     if(pgdir[i] & PTE_P){
1862       char * v = P2V(PTE_ADDR(pgdir[i]));
1863       kfree(v);
1864     }
1865   }
1866   kfree((char*)pgdir);
1867 }
1868 
1869 
1870 
1871 void
1872 clearpteu(pde_t *pgdir, char *uva)
1873 {
1874   pte_t *pte;
1875 
1876   pte = walkpgdir(pgdir, uva, 0);
1877   if(pte == 0)
1878     panic("clearpteu");
1879   *pte &= ~PTE_U;
1880 }
1881 
1882 
1883 
1884 pde_t*
1885 copyuvm(pde_t *pgdir, uint sz)
1886 {
1887   pde_t *d;
1888   pte_t *pte;
1889   uint pa, i, flags;
1890   char *mem;
1891 
1892   if((d = setupkvm()) == 0)
1893     return 0;
1894   for(i = 0; i < sz; i += PGSIZE){
1895     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1896       panic("copyuvm: pte should exist");
1897     if(!(*pte & PTE_P))
1898       panic("copyuvm: page not present");
1899     pa = PTE_ADDR(*pte);
1900     flags = PTE_FLAGS(*pte);
1901     if((mem = kalloc()) == 0)
1902       goto bad;
1903     memmove(mem, (char*)P2V(pa), PGSIZE);
1904     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
1905       kfree(mem);
1906       goto bad;
1907     }
1908   }
1909   return d;
1910 
1911 bad:
1912   freevm(d);
1913   return 0;
1914 }
1915 
1916 
1917 char*
1918 uva2ka(pde_t *pgdir, char *uva)
1919 {
1920   pte_t *pte;
1921 
1922   pte = walkpgdir(pgdir, uva, 0);
1923   if((*pte & PTE_P) == 0)
1924     return 0;
1925   if((*pte & PTE_U) == 0)
1926     return 0;
1927   return (char*)P2V(PTE_ADDR(*pte));
1928 }
1929 
1930 
1931 
1932 
1933 int
1934 copyout(pde_t *pgdir, uint va, void *p, uint len)
1935 {
1936   char *buf, *pa0;
1937   uint n, va0;
1938 
1939   buf = (char*)p;
1940   while(len > 0){
1941     va0 = (uint)PGROUNDDOWN(va);
1942     pa0 = uva2ka(pgdir, (char*)va0);
1943     if(pa0 == 0)
1944       return -1;
1945     n = PGSIZE - (va - va0);
1946     if(n > len)
1947       n = len;
1948     memmove(pa0 + (va - va0), buf, n);
1949     len -= n;
1950     buf += n;
1951     va = va0 + PGSIZE;
1952   }
1953   return 0;
1954 }
1955 
1956 
1957 
1958 
1959 
1960 
1961 
1962 
1963 
1964 
1965 
1966 
1967 
1968 
1969 
1970 
1971 
1972 
1973 
1974 
1975 
1976 
1977 
1978 
1979 
1980 
1981 
1982 
1983 
1984 
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 struct cpu {
2002   uchar apicid;                
2003   struct context *scheduler;   
2004   struct taskstate ts;         
2005   struct segdesc gdt[NSEGS];   
2006   volatile uint started;       
2007   int ncli;                    
2008   int intena;                  
2009   struct proc *proc;           
2010 };
2011 
2012 extern struct cpu cpus[NCPU];
2013 extern int ncpu;
2014 
2015 
2016 
2017 
2018 
2019 
2020 
2021 
2022 
2023 
2024 
2025 struct context {
2026   uint edi;
2027   uint esi;
2028   uint ebx;
2029   uint ebp;
2030   uint eip;
2031 };
2032 
2033 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2034 
2035 
2036 struct proc {
2037   uint sz;                     
2038   pde_t* pgdir;                
2039   char *kstack;                
2040   enum procstate state;        
2041   int pid;                     
2042   struct proc *parent;         
2043   struct trapframe *tf;        
2044   struct context *context;     
2045   void *chan;                  
2046   int killed;                  
2047   struct file *ofile[NOFILE];  
2048   struct inode *cwd;           
2049   char name[16];               
2050   uint ctime;                  
2051   uint etime;                  
2052   uint rtime;                  
2053   uint last_check;             
2054   uint ltime;                  
2055   int priority;                
2056   int cur_queue;               
2057   uint slice_exhausted;        
2058 };
2059 
2060 
2061 
2062 
2063 
2064 
2065 
2066 
2067 
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 #include "types.h"
2101 #include "defs.h"
2102 #include "param.h"
2103 #include "memlayout.h"
2104 #include "mmu.h"
2105 #include "x86.h"
2106 #include "proc.h"
2107 #include "spinlock.h"
2108 
2109 struct {
2110   struct spinlock lock;
2111   struct proc proc[NPROC];
2112 } ptable;
2113 
2114 struct proc *queue_0[NPROC];
2115 struct proc *queue_1[NPROC];
2116 struct proc *queue_2[NPROC];
2117 struct proc *queue_3[NPROC];
2118 struct proc *queue_4[NPROC];
2119 
2120 int heads[5] = {0, 0, 0, 0, 0};
2121 int tails[5] = {0, 0, 0, 0, 0};
2122 int sizes[5] = {0, 0, 0, 0, 0};
2123 
2124 static struct proc *initproc;
2125 
2126 int nextpid = 1;
2127 extern void forkret(void);
2128 extern void trapret(void);
2129 
2130 static void wakeup1(void *chan);
2131 
2132 void
2133 add_to_queue(struct proc *p, int qno)
2134 {
2135   struct proc **queue;
2136   switch(qno){
2137     case 0:
2138       queue = queue_0;
2139       break;
2140     case 1:
2141       queue = queue_1;
2142       break;
2143     case 2:
2144       queue = queue_2;
2145       break;
2146     case 3:
2147       queue = queue_3;
2148       break;
2149     case 4:
2150       queue = queue_4;
2151       break;
2152     default:
2153       panic("invalid queue requested");
2154   }
2155   queue[tails[qno]] = p;
2156   tails[qno] = (tails[qno] + 1) % NPROC;
2157   sizes[qno]++;
2158   p->cur_queue = qno;
2159 }
2160 
2161 void
2162 pop_queue(int qno){
2163   heads[qno] = (heads[qno] + 1) % NPROC;
2164   sizes[qno]--;
2165 }
2166 
2167 void
2168 remove_from_queue(struct proc *p)
2169 {
2170   struct proc **queue;
2171   int qno = p->cur_queue;
2172   switch(qno){
2173     case 0:
2174       queue = queue_0;
2175       break;
2176     case 1:
2177       queue = queue_1;
2178       break;
2179     case 2:
2180       queue = queue_2;
2181       break;
2182     case 3:
2183       queue = queue_3;
2184       break;
2185     case 4:
2186       queue = queue_4;
2187       break;
2188     default:
2189       panic("invalid queue requested");
2190   }
2191 
2192   int i = heads[qno];
2193   struct proc *tmp;
2194   for(; i != tails[qno]; i = (i+1)%NPROC){
2195     tmp = queue[i];
2196     if(tmp->pid == p->pid){
2197       queue[i] = 0;
2198       sizes[qno]--;
2199       break;
2200     }
2201   }
2202   clean_queue(qno);
2203 }
2204 
2205 void
2206 clean_queue(int qno)
2207 {
2208   struct proc **queue;
2209   switch(qno){
2210     case 0:
2211       queue = queue_0;
2212       break;
2213     case 1:
2214       queue = queue_1;
2215       break;
2216     case 2:
2217       queue = queue_2;
2218       break;
2219     case 3:
2220       queue = queue_3;
2221       break;
2222     case 4:
2223       queue = queue_4;
2224       break;
2225     default:
2226       panic("invalid queue requested");
2227   }
2228 
2229   int i;
2230   for(i = heads[qno]; i != tails[qno]; i = (i+1)%NPROC){
2231     if(queue[i] == 0){
2232       int j;
2233       struct proc *tmp;
2234       struct proc *old;
2235       tmp = queue[heads[qno]];
2236       for(j = heads[qno]; j != i; j = (j+1)%NPROC){
2237         old = queue[(j+1)%NPROC];
2238         queue[(j+1)%NPROC] = tmp;
2239         tmp = old;
2240       }
2241       heads[qno]++;
2242     }
2243   }
2244 }
2245 
2246 
2247 
2248 
2249 
2250 void
2251 pinit(void)
2252 {
2253   initlock(&ptable.lock, "ptable");
2254 }
2255 
2256 
2257 int
2258 cpuid() {
2259   return mycpu()-cpus;
2260 }
2261 
2262 
2263 
2264 struct cpu*
2265 mycpu(void)
2266 {
2267   int apicid, i;
2268 
2269   if(readeflags()&FL_IF)
2270     panic("mycpu called with interrupts enabled\n");
2271 
2272   apicid = lapicid();
2273   
2274   
2275   for (i = 0; i < ncpu; ++i) {
2276     if (cpus[i].apicid == apicid)
2277       return &cpus[i];
2278   }
2279   panic("unknown apicid\n");
2280 }
2281 
2282 
2283 
2284 struct proc*
2285 myproc(void) {
2286   struct cpu *c;
2287   struct proc *p;
2288   pushcli();
2289   c = mycpu();
2290   p = c->proc;
2291   popcli();
2292   return p;
2293 }
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 
2302 
2303 
2304 static struct proc*
2305 allocproc(void)
2306 {
2307   struct proc *p;
2308   char *sp;
2309 
2310   acquire(&ptable.lock);
2311 
2312   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2313     if(p->state == UNUSED)
2314       goto found;
2315 
2316   release(&ptable.lock);
2317   return 0;
2318 
2319 found:
2320   p->state = EMBRYO;
2321   p->pid = nextpid++;
2322   p->ctime = ticks;
2323   p->rtime = 0;
2324   p->last_check = ticks;
2325   p->priority = 60;
2326 
2327   release(&ptable.lock);
2328 
2329   
2330   if((p->kstack = kalloc()) == 0){
2331     p->state = UNUSED;
2332     return 0;
2333   }
2334   sp = p->kstack + KSTACKSIZE;
2335 
2336   
2337   sp -= sizeof *p->tf;
2338   p->tf = (struct trapframe*)sp;
2339 
2340   
2341   
2342   sp -= 4;
2343   *(uint*)sp = (uint)trapret;
2344 
2345   sp -= sizeof *p->context;
2346   p->context = (struct context*)sp;
2347   memset(p->context, 0, sizeof *p->context);
2348   p->context->eip = (uint)forkret;
2349 
2350   return p;
2351 }
2352 
2353 
2354 void
2355 userinit(void)
2356 {
2357   struct proc *p;
2358   extern char _binary_initcode_start[], _binary_initcode_size[];
2359 
2360   p = allocproc();
2361 
2362   initproc = p;
2363   if((p->pgdir = setupkvm()) == 0)
2364     panic("userinit: out of memory?");
2365   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2366   p->sz = PGSIZE;
2367   memset(p->tf, 0, sizeof(*p->tf));
2368   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2369   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2370   p->tf->es = p->tf->ds;
2371   p->tf->ss = p->tf->ds;
2372   p->tf->eflags = FL_IF;
2373   p->tf->esp = PGSIZE;
2374   p->tf->eip = 0;  
2375 
2376   safestrcpy(p->name, "initcode", sizeof(p->name));
2377   p->cwd = namei("/");
2378 
2379   
2380   
2381   
2382   
2383   acquire(&ptable.lock);
2384 
2385   p->state = RUNNABLE;
2386   p->cur_queue = 0;
2387   add_to_queue(p, 0);
2388   p->ltime = ticks;
2389 
2390   release(&ptable.lock);
2391 }
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 
2401 
2402 int
2403 growproc(int n)
2404 {
2405   uint sz;
2406   struct proc *curproc = myproc();
2407 
2408   sz = curproc->sz;
2409   if(n > 0){
2410     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2411       return -1;
2412   } else if(n < 0){
2413     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2414       return -1;
2415   }
2416   curproc->sz = sz;
2417   switchuvm(curproc);
2418   return 0;
2419 }
2420 
2421 
2422 
2423 
2424 int
2425 fork(void)
2426 {
2427   int i, pid;
2428   struct proc *np;
2429   struct proc *curproc = myproc();
2430 
2431   
2432   if((np = allocproc()) == 0){
2433     return -1;
2434   }
2435 
2436   
2437   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2438     kfree(np->kstack);
2439     np->kstack = 0;
2440     np->state = UNUSED;
2441     return -1;
2442   }
2443   np->sz = curproc->sz;
2444   np->parent = curproc;
2445   *np->tf = *curproc->tf;
2446 
2447   
2448   np->tf->eax = 0;
2449 
2450   for(i = 0; i < NOFILE; i++)
2451     if(curproc->ofile[i])
2452       np->ofile[i] = filedup(curproc->ofile[i]);
2453   np->cwd = idup(curproc->cwd);
2454 
2455   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2456 
2457   pid = np->pid;
2458 
2459   acquire(&ptable.lock);
2460 
2461   np->state = RUNNABLE;
2462   add_to_queue(np, 0);
2463   np->cur_queue = 0;
2464   np->ltime = ticks;
2465 
2466   release(&ptable.lock);
2467 
2468   return pid;
2469 }
2470 
2471 
2472 
2473 
2474 void
2475 exit(void)
2476 {
2477   struct proc *curproc = myproc();
2478   struct proc *p;
2479   int fd;
2480 
2481   if(curproc == initproc)
2482     panic("init exiting");
2483 
2484   
2485   for(fd = 0; fd < NOFILE; fd++){
2486     if(curproc->ofile[fd]){
2487       fileclose(curproc->ofile[fd]);
2488       curproc->ofile[fd] = 0;
2489     }
2490   }
2491 
2492   begin_op();
2493   iput(curproc->cwd);
2494   end_op();
2495   curproc->cwd = 0;
2496 
2497   acquire(&ptable.lock);
2498 
2499 
2500   
2501   wakeup1(curproc->parent);
2502 
2503   
2504   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2505     if(p->parent == curproc){
2506       p->parent = initproc;
2507       if(p->state == ZOMBIE)
2508         wakeup1(initproc);
2509     }
2510   }
2511 
2512   
2513   curproc->state = ZOMBIE;
2514   curproc->etime = ticks;
2515   sched();
2516   panic("zombie exit");
2517 }
2518 
2519 
2520 
2521 int
2522 wait(void)
2523 {
2524   struct proc *p;
2525   int havekids, pid;
2526   struct proc *curproc = myproc();
2527 
2528   acquire(&ptable.lock);
2529   for(;;){
2530     
2531     havekids = 0;
2532     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2533       if(p->parent != curproc)
2534         continue;
2535       havekids = 1;
2536       if(p->state == ZOMBIE){
2537         
2538         pid = p->pid;
2539         kfree(p->kstack);
2540         p->kstack = 0;
2541         freevm(p->pgdir);
2542         p->pid = 0;
2543         p->parent = 0;
2544         p->name[0] = 0;
2545         p->killed = 0;
2546         p->state = UNUSED;
2547         p->etime = ticks;
2548         release(&ptable.lock);
2549         return pid;
2550       }
2551     }
2552 
2553     
2554     if(!havekids || curproc->killed){
2555       release(&ptable.lock);
2556       return -1;
2557     }
2558 
2559     
2560     sleep(curproc, &ptable.lock);  
2561   }
2562 }
2563 
2564 int
2565 waitx(int* wtime, int* rtime)
2566 {
2567   struct proc *curproc = myproc();
2568   struct proc *p;
2569   int havekids, pid;
2570 
2571   acquire(&ptable.lock);
2572   for(;;){
2573     
2574     havekids = 0;
2575     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2576       if(p->parent != curproc)
2577         continue;
2578       havekids = 1;
2579       if(p->state == ZOMBIE){
2580         
2581         pid = p->pid;
2582         kfree(p->kstack);
2583         p->kstack = 0;
2584         freevm(p->pgdir);
2585         p->pid = 0;
2586         p->parent = 0;
2587         p->name[0] = 0;
2588         p->killed = 0;
2589         p->state = UNUSED;
2590         p->etime = ticks;
2591         release(&ptable.lock);
2592         *rtime = p->rtime;
2593         *wtime = ticks - p->ctime - p->rtime;
2594         return pid;
2595       }
2596     }
2597 
2598 
2599 
2600     
2601     if(!havekids || curproc->killed){
2602       release(&ptable.lock);
2603       *rtime = -1;
2604       *wtime = -1;
2605       return -1;
2606     }
2607 
2608     
2609     sleep(curproc, &ptable.lock);  
2610   }
2611 }
2612 
2613 int
2614 setpriority(int priority)
2615 {
2616   struct proc *curproc = myproc();
2617   if(priority > 100 || priority < 0)
2618     return -1;
2619   int old_p = curproc->priority;
2620   curproc->priority = priority;
2621   if(priority < old_p){
2622     yield();
2623   }
2624   return old_p;
2625 }
2626 
2627 
2628 void
2629 update_times(struct proc* p)
2630 {
2631   if(p->state == RUNNING)
2632     p->rtime += ticks - p->last_check;
2633   p->last_check = ticks;
2634 }
2635 
2636 
2637 
2638 
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 
2655 
2656 
2657 void
2658 scheduler(void)
2659 {
2660   struct proc *p;
2661   struct cpu *c = mycpu();
2662   c->proc = 0;
2663 
2664   int scheduler_strat = 4;
2665   if(SCHEDFLAG[0] == 'F'){
2666     scheduler_strat = 1;
2667   }
2668   else if(SCHEDFLAG[0] == 'P'){
2669     scheduler_strat = 2;
2670   }
2671   else if(SCHEDFLAG[0] == 'M'){
2672     scheduler_strat = 3;
2673   }
2674 
2675   for(;;){
2676     
2677     sti();
2678 
2679     
2680     acquire(&ptable.lock);
2681 
2682     switch(scheduler_strat){
2683 
2684       case 1:{
2685         
2686         struct proc *to_run = 0;
2687         int min_ctime = ticks + 1000;
2688         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2689           update_times(p);
2690           if(p->state != RUNNABLE)
2691             continue;
2692 
2693           if(p->ctime < min_ctime){
2694             min_ctime = p->ctime;
2695             to_run = p;
2696           }
2697         }
2698         if(to_run){
2699           c->proc = to_run;
2700           switchuvm(to_run);
2701           to_run->state = RUNNING;
2702 
2703           swtch(&(c->scheduler), to_run->context);
2704           switchkvm();
2705 
2706           c->proc = 0;
2707         }
2708       }
2709       break;
2710 
2711       case 2:{
2712         
2713         int priority_chosen = 101;
2714         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2715           update_times(p);
2716           if(p->state != RUNNABLE)
2717             continue;
2718           if(p->priority < priority_chosen)
2719             priority_chosen = p->priority;
2720         }
2721         for(p = ptable.proc; p < &ptable.proc[NPROC] && priority_chosen != 101; p++){
2722           update_times(p);
2723           if(p->state != RUNNABLE)
2724             continue;
2725           if(p->priority == priority_chosen){
2726             c->proc = p;
2727             switchuvm(p);
2728             p->state = RUNNING;
2729 
2730             swtch(&(c->scheduler), p->context);
2731             switchkvm();
2732 
2733             c->proc = 0;
2734           }
2735         }
2736       }
2737       break;
2738 
2739       case 3:{
2740         
2741         struct proc *to_run = 0;
2742         if(sizes[0] != 0){
2743           to_run = queue_0[heads[0]];
2744           pop_queue(0);
2745         }
2746         else if(sizes[1] != 0){
2747           to_run = queue_1[heads[1]];
2748           pop_queue(1);
2749         }
2750         else if(sizes[2] != 0){
2751           to_run = queue_2[heads[2]];
2752           pop_queue(2);
2753         }
2754         else if(sizes[3] != 0){
2755           to_run = queue_3[heads[3]];
2756           pop_queue(3);
2757         }
2758         else if(sizes[4] != 0){
2759           to_run = queue_4[heads[4]];
2760           pop_queue(4);
2761         }
2762         if(to_run != 0){
2763           while(1){
2764             c->proc = to_run;
2765             switchuvm(to_run);
2766             to_run->state = RUNNING;
2767             to_run->ltime = ticks;
2768 
2769             swtch(&(c->scheduler), to_run->context);
2770             switchkvm();
2771 
2772             c->proc = 0;
2773 
2774             if(to_run->state == RUNNABLE && !to_run->slice_exhausted){
2775               continue;
2776             }
2777             if(to_run->state == RUNNABLE && to_run->slice_exhausted){
2778               if(to_run->cur_queue != 4){
2779                 to_run->cur_queue++;
2780                 add_to_queue(to_run, to_run->cur_queue+1);
2781               }
2782               else{
2783                 add_to_queue(to_run, to_run->cur_queue);
2784               }
2785               break;
2786             }
2787           }
2788         }
2789         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2790           update_times(p);
2791           if(p->state != RUNNABLE)
2792             continue;
2793 
2794           if(ticks - p->ltime > 50 && p->cur_queue != 0){
2795             p->ltime = ticks;
2796             remove_from_queue(p);
2797             add_to_queue(p, p->cur_queue-1);
2798           }
2799         }
2800       }
2801       break;
2802 
2803       case 4:{
2804         
2805         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2806           update_times(p);
2807           if(p->state != RUNNABLE)
2808             continue;
2809 
2810           
2811           
2812           
2813           c->proc = p;
2814           switchuvm(p);
2815           p->state = RUNNING;
2816 
2817           swtch(&(c->scheduler), p->context);
2818           switchkvm();
2819 
2820           
2821           
2822           c->proc = 0;
2823         }
2824       }
2825       break;
2826       default:
2827         panic("invalid scheduling");
2828     }
2829     release(&ptable.lock);
2830   }
2831 }
2832 
2833 
2834 
2835 
2836 
2837 
2838 
2839 
2840 void
2841 sched(void)
2842 {
2843   int intena;
2844   struct proc *p = myproc();
2845 
2846   if(!holding(&ptable.lock))
2847     panic("sched ptable.lock");
2848   if(mycpu()->ncli != 1)
2849     panic("sched locks");
2850   if(p->state == RUNNING)
2851     panic("sched running");
2852   if(readeflags()&FL_IF)
2853     panic("sched interruptible");
2854   intena = mycpu()->intena;
2855   swtch(&p->context, mycpu()->scheduler);
2856   mycpu()->intena = intena;
2857 }
2858 
2859 
2860 void
2861 yield(void)
2862 {
2863   acquire(&ptable.lock);  
2864   myproc()->state = RUNNABLE;
2865   sched();
2866   release(&ptable.lock);
2867 }
2868 
2869 
2870 
2871 void
2872 forkret(void)
2873 {
2874   static int first = 1;
2875   
2876   release(&ptable.lock);
2877 
2878   if (first) {
2879     
2880     
2881     
2882     first = 0;
2883     iinit(ROOTDEV);
2884     initlog(ROOTDEV);
2885   }
2886 
2887   
2888 }
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 void
2903 sleep(void *chan, struct spinlock *lk)
2904 {
2905   struct proc *p = myproc();
2906 
2907   if(p == 0)
2908     panic("sleep");
2909 
2910   if(lk == 0)
2911     panic("sleep without lk");
2912 
2913   
2914   
2915   
2916   
2917   
2918   
2919   if(lk != &ptable.lock){  
2920     acquire(&ptable.lock);  
2921     release(lk);
2922   }
2923   
2924   p->chan = chan;
2925   p->state = SLEEPING;
2926   remove_from_queue(p);
2927 
2928   sched();
2929 
2930   
2931   p->chan = 0;
2932 
2933   
2934   if(lk != &ptable.lock){  
2935     release(&ptable.lock);
2936     acquire(lk);
2937   }
2938 }
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 static void
2953 wakeup1(void *chan)
2954 {
2955   struct proc *p;
2956 
2957   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2958     if(p->state == SLEEPING && p->chan == chan){
2959       p->state = RUNNABLE;
2960       add_to_queue(p, p->cur_queue);
2961     }
2962 }
2963 
2964 
2965 void
2966 wakeup(void *chan)
2967 {
2968   acquire(&ptable.lock);
2969   wakeup1(chan);
2970   release(&ptable.lock);
2971 }
2972 
2973 
2974 
2975 
2976 int
2977 kill(int pid)
2978 {
2979   struct proc *p;
2980 
2981   acquire(&ptable.lock);
2982   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2983     if(p->pid == pid){
2984       p->killed = 1;
2985       
2986       if(p->state == SLEEPING)
2987         p->state = RUNNABLE;
2988       release(&ptable.lock);
2989       return 0;
2990     }
2991   }
2992   release(&ptable.lock);
2993   return -1;
2994 }
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 
3003 void
3004 procdump(void)
3005 {
3006   static char *states[] = {
3007   [UNUSED]    "unused",
3008   [EMBRYO]    "embryo",
3009   [SLEEPING]  "sleep ",
3010   [RUNNABLE]  "runble",
3011   [RUNNING]   "run   ",
3012   [ZOMBIE]    "zombie"
3013   };
3014   int i;
3015   struct proc *p;
3016   char *state;
3017   uint pc[10];
3018 
3019   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3020     if(p->state == UNUSED)
3021       continue;
3022     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3023       state = states[p->state];
3024     else
3025       state = "???";
3026     cprintf("%d %s %s", p->pid, state, p->name);
3027     if(p->state == SLEEPING){
3028       getcallerpcs((uint*)p->context->ebp+2, pc);
3029       for(i=0; i<10 && pc[i] != 0; i++)
3030         cprintf(" %p", pc[i]);
3031     }
3032     cprintf("\n");
3033   }
3034 }
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053 
3054 
3055 
3056 
3057 
3058 .globl swtch
3059 swtch:
3060   movl 4(%esp), %eax
3061   movl 8(%esp), %edx
3062 
3063   
3064   pushl %ebp
3065   pushl %ebx
3066   pushl %esi
3067   pushl %edi
3068 
3069   
3070   movl %esp, (%eax)
3071   movl %edx, %esp
3072 
3073   
3074   popl %edi
3075   popl %esi
3076   popl %ebx
3077   popl %ebp
3078   ret
3079 
3080 
3081 
3082 
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 
3101 
3102 
3103 
3104 #include "types.h"
3105 #include "defs.h"
3106 #include "param.h"
3107 #include "memlayout.h"
3108 #include "mmu.h"
3109 #include "spinlock.h"
3110 
3111 void freerange(void *vstart, void *vend);
3112 extern char end[]; 
3113                    
3114 
3115 struct run {
3116   struct run *next;
3117 };
3118 
3119 struct {
3120   struct spinlock lock;
3121   int use_lock;
3122   struct run *freelist;
3123 } kmem;
3124 
3125 
3126 
3127 
3128 
3129 
3130 void
3131 kinit1(void *vstart, void *vend)
3132 {
3133   initlock(&kmem.lock, "kmem");
3134   kmem.use_lock = 0;
3135   freerange(vstart, vend);
3136 }
3137 
3138 void
3139 kinit2(void *vstart, void *vend)
3140 {
3141   freerange(vstart, vend);
3142   kmem.use_lock = 1;
3143 }
3144 
3145 
3146 
3147 
3148 
3149 
3150 void
3151 freerange(void *vstart, void *vend)
3152 {
3153   char *p;
3154   p = (char*)PGROUNDUP((uint)vstart);
3155   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3156     kfree(p);
3157 }
3158 
3159 
3160 
3161 
3162 void
3163 kfree(char *v)
3164 {
3165   struct run *r;
3166 
3167   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3168     panic("kfree");
3169 
3170   
3171   memset(v, 1, PGSIZE);
3172 
3173   if(kmem.use_lock)
3174     acquire(&kmem.lock);
3175   r = (struct run*)v;
3176   r->next = kmem.freelist;
3177   kmem.freelist = r;
3178   if(kmem.use_lock)
3179     release(&kmem.lock);
3180 }
3181 
3182 
3183 
3184 
3185 char*
3186 kalloc(void)
3187 {
3188   struct run *r;
3189 
3190   if(kmem.use_lock)
3191     acquire(&kmem.lock);
3192   r = kmem.freelist;
3193   if(r)
3194     kmem.freelist = r->next;
3195   if(kmem.use_lock)
3196     release(&kmem.lock);
3197   return (char*)r;
3198 }
3199 
3200 
3201 
3202 
3203 #define T_DIVIDE         0      
3204 #define T_DEBUG          1      
3205 #define T_NMI            2      
3206 #define T_BRKPT          3      
3207 #define T_OFLOW          4      
3208 #define T_BOUND          5      
3209 #define T_ILLOP          6      
3210 #define T_DEVICE         7      
3211 #define T_DBLFLT         8      
3212 
3213 #define T_TSS           10      
3214 #define T_SEGNP         11      
3215 #define T_STACK         12      
3216 #define T_GPFLT         13      
3217 #define T_PGFLT         14      
3218 
3219 #define T_FPERR         16      
3220 #define T_ALIGN         17      
3221 #define T_MCHK          18      
3222 #define T_SIMDERR       19      
3223 
3224 
3225 
3226 #define T_SYSCALL       64      
3227 #define T_DEFAULT      500      
3228 
3229 #define T_IRQ0          32      
3230 
3231 #define IRQ_TIMER        0
3232 #define IRQ_KBD          1
3233 #define IRQ_COM1         4
3234 #define IRQ_IDE         14
3235 #define IRQ_ERROR       19
3236 #define IRQ_SPURIOUS    31
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #!/usr/bin/perl -w
3251 
3252 # Generate vectors.S, the trap/interrupt entry points.
3253 # There has to be one entry point per interrupt number
3254 # since otherwise there's no way for trap() to discover
3255 # the interrupt number.
3256 
3257 print "# generated by vectors.pl - do not edit\n";
3258 print "# handlers\n";
3259 print ".globl alltraps\n";
3260 for(my $i = 0; $i < 256; $i++){
3261     print ".globl vector$i\n";
3262     print "vector$i:\n";
3263     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3264         print "  pushl \$0\n";
3265     }
3266     print "  pushl \$$i\n";
3267     print "  jmp alltraps\n";
3268 }
3269 
3270 print "\n# vector table\n";
3271 print ".data\n";
3272 print ".globl vectors\n";
3273 print "vectors:\n";
3274 for(my $i = 0; $i < 256; $i++){
3275     print "  .long vector$i\n";
3276 }
3277 
3278 # sample output:
3279 #   # handlers
3280 #   .globl alltraps
3281 #   .globl vector0
3282 #   vector0:
3283 #     pushl $0
3284 #     pushl $0
3285 #     jmp alltraps
3286 #   ...
3287 #
3288 #   # vector table
3289 #   .data
3290 #   .globl vectors
3291 #   vectors:
3292 #     .long vector0
3293 #     .long vector1
3294 #     .long vector2
3295 #   ...
3296 
3297 
3298 
3299 
3300 
3301 
3302   
3303 .globl alltraps
3304 alltraps:
3305   
3306   pushl %ds
3307   pushl %es
3308   pushl %fs
3309   pushl %gs
3310   pushal
3311 
3312   
3313   movw $(SEG_KDATA<<3), %ax
3314   movw %ax, %ds
3315   movw %ax, %es
3316 
3317   
3318   pushl %esp
3319   call trap
3320   addl $4, %esp
3321 
3322   
3323 .globl trapret
3324 trapret:
3325   popal
3326   popl %gs
3327   popl %fs
3328   popl %es
3329   popl %ds
3330   addl $0x8, %esp  
3331   iret
3332 
3333 
3334 
3335 
3336 
3337 
3338 
3339 
3340 
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 #include "types.h"
3351 #include "defs.h"
3352 #include "param.h"
3353 #include "memlayout.h"
3354 #include "mmu.h"
3355 #include "proc.h"
3356 #include "x86.h"
3357 #include "traps.h"
3358 #include "spinlock.h"
3359 
3360 
3361 struct gatedesc idt[256];
3362 extern uint vectors[];  
3363 struct spinlock tickslock;
3364 uint ticks;
3365 uint cnt_to_yield = 0;
3366 
3367 void
3368 tvinit(void)
3369 {
3370   int i;
3371 
3372   for(i = 0; i < 256; i++)
3373     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3374   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3375 
3376   initlock(&tickslock, "time");
3377 }
3378 
3379 void
3380 idtinit(void)
3381 {
3382   lidt(idt, sizeof(idt));
3383 }
3384 
3385 void
3386 trap(struct trapframe *tf)
3387 {
3388   if(tf->trapno == T_SYSCALL){
3389     if(myproc()->killed)
3390       exit();
3391     myproc()->tf = tf;
3392     syscall();
3393     if(myproc()->killed)
3394       exit();
3395     return;
3396   }
3397 
3398   switch(tf->trapno){
3399   case T_IRQ0 + IRQ_TIMER:
3400     if(cpuid() == 0){
3401       acquire(&tickslock);
3402       ticks++;
3403       wakeup(&ticks);
3404       release(&tickslock);
3405     }
3406     lapiceoi();
3407     break;
3408   case T_IRQ0 + IRQ_IDE:
3409     ideintr();
3410     lapiceoi();
3411     break;
3412   case T_IRQ0 + IRQ_IDE+1:
3413     
3414     break;
3415   case T_IRQ0 + IRQ_KBD:
3416     kbdintr();
3417     lapiceoi();
3418     break;
3419   case T_IRQ0 + IRQ_COM1:
3420     uartintr();
3421     lapiceoi();
3422     break;
3423   case T_IRQ0 + 7:
3424   case T_IRQ0 + IRQ_SPURIOUS:
3425     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3426             cpuid(), tf->cs, tf->eip);
3427     lapiceoi();
3428     break;
3429 
3430   default:
3431     if(myproc() == 0 || (tf->cs&3) == 0){
3432       
3433       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3434               tf->trapno, cpuid(), tf->eip, rcr2());
3435       panic("trap");
3436     }
3437     
3438     cprintf("pid %d %s: trap %d err %d on cpu %d "
3439             "eip 0x%x addr 0x%x--kill proc\n",
3440             myproc()->pid, myproc()->name, tf->trapno,
3441             tf->err, cpuid(), tf->eip, rcr2());
3442     myproc()->killed = 1;
3443   }
3444 
3445   
3446   
3447   
3448   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3449     exit();
3450   
3451   
3452   if(myproc() && myproc()->state == RUNNING &&
3453      tf->trapno == T_IRQ0+IRQ_TIMER && SCHEDFLAG[0] != 'F' && SCHEDFLAG[0] != 'M')
3454     yield();
3455 
3456   if(SCHEDFLAG[0] == 'M'){
3457     if(myproc()->cur_queue == 0){
3458       if(myproc() && myproc()->state == RUNNING &&
3459           tf->trapno == T_IRQ0+IRQ_TIMER){
3460         myproc()->slice_exhausted = 1;
3461         yield();
3462       }
3463     }
3464     else if(myproc()->cur_queue == 1){
3465       if(cnt_to_yield == 1){
3466         myproc()->slice_exhausted = 1;
3467         cnt_to_yield = 0;
3468         yield();
3469       }
3470       if(myproc() && myproc()->state == RUNNING &&
3471           tf->trapno == T_IRQ0+IRQ_TIMER)
3472         cnt_to_yield++;
3473     }
3474     else if(myproc()->cur_queue == 2){
3475       if(cnt_to_yield == 3){
3476         myproc()->slice_exhausted = 1;
3477         cnt_to_yield = 0;
3478         yield();
3479       }
3480       if(myproc() && myproc()->state == RUNNING &&
3481           tf->trapno == T_IRQ0+IRQ_TIMER)
3482         cnt_to_yield++;
3483     }
3484     else if(myproc()->cur_queue == 3){
3485       if(cnt_to_yield == 7){
3486         myproc()->slice_exhausted = 1;
3487         cnt_to_yield = 0;
3488         yield();
3489       }
3490       if(myproc() && myproc()->state == RUNNING &&
3491           tf->trapno == T_IRQ0+IRQ_TIMER)
3492         cnt_to_yield++;
3493     }
3494     else if(myproc()->cur_queue == 4){
3495       if(cnt_to_yield == 15){
3496         myproc()->slice_exhausted = 1;
3497         cnt_to_yield = 0;
3498         yield();
3499       }
3500       if(myproc() && myproc()->state == RUNNING &&
3501           tf->trapno == T_IRQ0+IRQ_TIMER)
3502         cnt_to_yield++;
3503     }
3504   }
3505 
3506   
3507   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3508     exit();
3509 }
3510 
3511 
3512 
3513 
3514 
3515 
3516 
3517 
3518 
3519 
3520 
3521 
3522 
3523 
3524 
3525 
3526 
3527 
3528 
3529 
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 
3551 #define SYS_fork    1
3552 #define SYS_exit    2
3553 #define SYS_wait    3
3554 #define SYS_pipe    4
3555 #define SYS_read    5
3556 #define SYS_kill    6
3557 #define SYS_exec    7
3558 #define SYS_fstat   8
3559 #define SYS_chdir   9
3560 #define SYS_dup    10
3561 #define SYS_getpid 11
3562 #define SYS_sbrk   12
3563 #define SYS_sleep  13
3564 #define SYS_uptime 14
3565 #define SYS_open   15
3566 #define SYS_write  16
3567 #define SYS_mknod  17
3568 #define SYS_unlink 18
3569 #define SYS_link   19
3570 #define SYS_mkdir  20
3571 #define SYS_close  21
3572 #define SYS_waitx  22
3573 #define SYS_setpriority 23
3574 
3575 
3576 
3577 
3578 
3579 
3580 
3581 
3582 
3583 
3584 
3585 
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 #include "types.h"
3601 #include "defs.h"
3602 #include "param.h"
3603 #include "memlayout.h"
3604 #include "mmu.h"
3605 #include "proc.h"
3606 #include "x86.h"
3607 #include "syscall.h"
3608 
3609 
3610 
3611 
3612 
3613 
3614 
3615 
3616 int
3617 fetchint(uint addr, int *ip)
3618 {
3619   struct proc *curproc = myproc();
3620 
3621   if(addr >= curproc->sz || addr+4 > curproc->sz)
3622     return -1;
3623   *ip = *(int*)(addr);
3624   return 0;
3625 }
3626 
3627 
3628 
3629 
3630 int
3631 fetchstr(uint addr, char **pp)
3632 {
3633   char *s, *ep;
3634   struct proc *curproc = myproc();
3635 
3636   if(addr >= curproc->sz)
3637     return -1;
3638   *pp = (char*)addr;
3639   ep = (char*)curproc->sz;
3640   for(s = *pp; s < ep; s++){
3641     if(*s == 0)
3642       return s - *pp;
3643   }
3644   return -1;
3645 }
3646 
3647 
3648 
3649 
3650 
3651 int
3652 argint(int n, int *ip)
3653 {
3654   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3655 }
3656 
3657 
3658 
3659 
3660 int
3661 argptr(int n, char **pp, int size)
3662 {
3663   int i;
3664   struct proc *curproc = myproc();
3665 
3666   if(argint(n, &i) < 0)
3667     return -1;
3668   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3669     return -1;
3670   *pp = (char*)i;
3671   return 0;
3672 }
3673 
3674 
3675 
3676 
3677 
3678 int
3679 argstr(int n, char **pp)
3680 {
3681   int addr;
3682   if(argint(n, &addr) < 0)
3683     return -1;
3684   return fetchstr(addr, pp);
3685 }
3686 
3687 
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 extern int sys_chdir(void);
3701 extern int sys_close(void);
3702 extern int sys_dup(void);
3703 extern int sys_exec(void);
3704 extern int sys_exit(void);
3705 extern int sys_fork(void);
3706 extern int sys_fstat(void);
3707 extern int sys_getpid(void);
3708 extern int sys_kill(void);
3709 extern int sys_link(void);
3710 extern int sys_mkdir(void);
3711 extern int sys_mknod(void);
3712 extern int sys_open(void);
3713 extern int sys_pipe(void);
3714 extern int sys_read(void);
3715 extern int sys_sbrk(void);
3716 extern int sys_sleep(void);
3717 extern int sys_unlink(void);
3718 extern int sys_wait(void);
3719 extern int sys_waitx(void);
3720 extern int sys_write(void);
3721 extern int sys_uptime(void);
3722 extern int sys_setpriority(void);
3723 
3724 static int (*syscalls[])(void) = {
3725 [SYS_fork]    sys_fork,
3726 [SYS_exit]    sys_exit,
3727 [SYS_wait]    sys_wait,
3728 [SYS_waitx]   sys_waitx,
3729 [SYS_pipe]    sys_pipe,
3730 [SYS_read]    sys_read,
3731 [SYS_kill]    sys_kill,
3732 [SYS_exec]    sys_exec,
3733 [SYS_fstat]   sys_fstat,
3734 [SYS_chdir]   sys_chdir,
3735 [SYS_dup]     sys_dup,
3736 [SYS_getpid]  sys_getpid,
3737 [SYS_sbrk]    sys_sbrk,
3738 [SYS_sleep]   sys_sleep,
3739 [SYS_uptime]  sys_uptime,
3740 [SYS_open]    sys_open,
3741 [SYS_write]   sys_write,
3742 [SYS_mknod]   sys_mknod,
3743 [SYS_unlink]  sys_unlink,
3744 [SYS_link]    sys_link,
3745 [SYS_mkdir]   sys_mkdir,
3746 [SYS_close]   sys_close,
3747 [SYS_setpriority] sys_setpriority,
3748 };
3749 
3750 void
3751 syscall(void)
3752 {
3753   int num;
3754   struct proc *curproc = myproc();
3755 
3756   num = curproc->tf->eax;
3757   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3758     curproc->tf->eax = syscalls[num]();
3759   } else {
3760     cprintf("%d %s: unknown sys call %d\n",
3761             curproc->pid, curproc->name, num);
3762     curproc->tf->eax = -1;
3763   }
3764 }
3765 
3766 
3767 
3768 
3769 
3770 
3771 
3772 
3773 
3774 
3775 
3776 
3777 
3778 
3779 
3780 
3781 
3782 
3783 
3784 
3785 
3786 
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 #include "types.h"
3801 #include "x86.h"
3802 #include "defs.h"
3803 #include "date.h"
3804 #include "param.h"
3805 #include "memlayout.h"
3806 #include "mmu.h"
3807 #include "proc.h"
3808 
3809 int
3810 sys_fork(void)
3811 {
3812   return fork();
3813 }
3814 
3815 int
3816 sys_exit(void)
3817 {
3818   exit();
3819   return 0;  
3820 }
3821 
3822 int
3823 sys_wait(void)
3824 {
3825   return wait();
3826 }
3827 
3828 int
3829 sys_setpriority(void)
3830 {
3831   int p;
3832   if(argint(0, &p) < 0)
3833     return -1;
3834   return setpriority(p);
3835 }
3836 
3837 int
3838 sys_waitx(void)
3839 {
3840   int* wtime;
3841   int* rtime;
3842   if(argptr(0, (void*)&wtime, sizeof(int)) || argptr(1, (void*)&rtime, sizeof(int)))
3843     return -1;
3844   return waitx((int*)wtime, (int*)rtime);
3845 }
3846 
3847 
3848 
3849 
3850 int
3851 sys_kill(void)
3852 {
3853   int pid;
3854 
3855   if(argint(0, &pid) < 0)
3856     return -1;
3857   return kill(pid);
3858 }
3859 
3860 int
3861 sys_getpid(void)
3862 {
3863   return myproc()->pid;
3864 }
3865 
3866 int
3867 sys_sbrk(void)
3868 {
3869   int addr;
3870   int n;
3871 
3872   if(argint(0, &n) < 0)
3873     return -1;
3874   addr = myproc()->sz;
3875   if(growproc(n) < 0)
3876     return -1;
3877   return addr;
3878 }
3879 
3880 int
3881 sys_sleep(void)
3882 {
3883   int n;
3884   uint ticks0;
3885 
3886   if(argint(0, &n) < 0)
3887     return -1;
3888   acquire(&tickslock);
3889   ticks0 = ticks;
3890   while(ticks - ticks0 < n){
3891     if(myproc()->killed){
3892       release(&tickslock);
3893       return -1;
3894     }
3895     sleep(&ticks, &tickslock);
3896   }
3897   release(&tickslock);
3898   return 0;
3899 }
3900 
3901 
3902 int
3903 sys_uptime(void)
3904 {
3905   uint xticks;
3906 
3907   acquire(&tickslock);
3908   xticks = ticks;
3909   release(&tickslock);
3910   return xticks;
3911 }
3912 
3913 
3914 
3915 
3916 
3917 
3918 
3919 
3920 
3921 
3922 
3923 
3924 
3925 
3926 
3927 
3928 
3929 
3930 
3931 
3932 
3933 
3934 
3935 
3936 
3937 
3938 
3939 
3940 
3941 
3942 
3943 
3944 
3945 
3946 
3947 
3948 
3949 
3950 struct buf {
3951   int flags;
3952   uint dev;
3953   uint blockno;
3954   struct sleeplock lock;
3955   uint refcnt;
3956   struct buf *prev; 
3957   struct buf *next;
3958   struct buf *qnext; 
3959   uchar data[BSIZE];
3960 };
3961 #define B_VALID 0x2  
3962 #define B_DIRTY 0x4  
3963 
3964 
3965 
3966 
3967 
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 struct sleeplock {
4002   uint locked;       
4003   struct spinlock lk; 
4004 
4005   
4006   char *name;        
4007   int pid;           
4008 };
4009 
4010 
4011 
4012 
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 #define O_RDONLY  0x000
4051 #define O_WRONLY  0x001
4052 #define O_RDWR    0x002
4053 #define O_CREATE  0x200
4054 
4055 
4056 
4057 
4058 
4059 
4060 
4061 
4062 
4063 
4064 
4065 
4066 
4067 
4068 
4069 
4070 
4071 
4072 
4073 
4074 
4075 
4076 
4077 
4078 
4079 
4080 
4081 
4082 
4083 
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 #define T_DIR  1   
4101 #define T_FILE 2   
4102 #define T_DEV  3   
4103 
4104 struct stat {
4105   short type;  
4106   int dev;     
4107   uint ino;    
4108   short nlink; 
4109   uint size;   
4110 };
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 
4152 
4153 
4154 #define ROOTINO 1  
4155 #define BSIZE 512  
4156 
4157 
4158 
4159 
4160 
4161 
4162 
4163 struct superblock {
4164   uint size;         
4165   uint nblocks;      
4166   uint ninodes;      
4167   uint nlog;         
4168   uint logstart;     
4169   uint inodestart;   
4170   uint bmapstart;    
4171 };
4172 
4173 #define NDIRECT 12
4174 #define NINDIRECT (BSIZE / sizeof(uint))
4175 #define MAXFILE (NDIRECT + NINDIRECT)
4176 
4177 
4178 struct dinode {
4179   short type;           
4180   short major;          
4181   short minor;          
4182   short nlink;          
4183   uint size;            
4184   uint addrs[NDIRECT+1];   
4185 };
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 
4201 #define IPB           (BSIZE / sizeof(struct dinode))
4202 
4203 
4204 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4205 
4206 
4207 #define BPB           (BSIZE*8)
4208 
4209 
4210 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4211 
4212 
4213 #define DIRSIZ 14
4214 
4215 struct dirent {
4216   ushort inum;
4217   char name[DIRSIZ];
4218 };
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 struct file {
4251   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4252   int ref; 
4253   char readable;
4254   char writable;
4255   struct pipe *pipe;
4256   struct inode *ip;
4257   uint off;
4258 };
4259 
4260 
4261 
4262 struct inode {
4263   uint dev;           
4264   uint inum;          
4265   int ref;            
4266   struct sleeplock lock; 
4267   int valid;          
4268 
4269   short type;         
4270   short major;
4271   short minor;
4272   short nlink;
4273   uint size;
4274   uint addrs[NDIRECT+1];
4275 };
4276 
4277 
4278 
4279 struct devsw {
4280   int (*read)(struct inode*, char*, int);
4281   int (*write)(struct inode*, char*, int);
4282 };
4283 
4284 extern struct devsw devsw[];
4285 
4286 #define CONSOLE 1
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 #include "types.h"
4303 #include "defs.h"
4304 #include "param.h"
4305 #include "memlayout.h"
4306 #include "mmu.h"
4307 #include "proc.h"
4308 #include "x86.h"
4309 #include "traps.h"
4310 #include "spinlock.h"
4311 #include "sleeplock.h"
4312 #include "fs.h"
4313 #include "buf.h"
4314 
4315 #define SECTOR_SIZE   512
4316 #define IDE_BSY       0x80
4317 #define IDE_DRDY      0x40
4318 #define IDE_DF        0x20
4319 #define IDE_ERR       0x01
4320 
4321 #define IDE_CMD_READ  0x20
4322 #define IDE_CMD_WRITE 0x30
4323 #define IDE_CMD_RDMUL 0xc4
4324 #define IDE_CMD_WRMUL 0xc5
4325 
4326 
4327 
4328 
4329 
4330 static struct spinlock idelock;
4331 static struct buf *idequeue;
4332 
4333 static int havedisk1;
4334 static void idestart(struct buf*);
4335 
4336 
4337 static int
4338 idewait(int checkerr)
4339 {
4340   int r;
4341 
4342   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4343     ;
4344   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4345     return -1;
4346   return 0;
4347 }
4348 
4349 
4350 void
4351 ideinit(void)
4352 {
4353   int i;
4354 
4355   initlock(&idelock, "ide");
4356   ioapicenable(IRQ_IDE, ncpu - 1);
4357   idewait(0);
4358 
4359   
4360   outb(0x1f6, 0xe0 | (1<<4));
4361   for(i=0; i<1000; i++){
4362     if(inb(0x1f7) != 0){
4363       havedisk1 = 1;
4364       break;
4365     }
4366   }
4367 
4368   
4369   outb(0x1f6, 0xe0 | (0<<4));
4370 }
4371 
4372 
4373 static void
4374 idestart(struct buf *b)
4375 {
4376   if(b == 0)
4377     panic("idestart");
4378   if(b->blockno >= FSSIZE)
4379     panic("incorrect blockno");
4380   int sector_per_block =  BSIZE/SECTOR_SIZE;
4381   int sector = b->blockno * sector_per_block;
4382   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4383   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4384 
4385   if (sector_per_block > 7) panic("idestart");
4386 
4387   idewait(0);
4388   outb(0x3f6, 0);  
4389   outb(0x1f2, sector_per_block);  
4390   outb(0x1f3, sector & 0xff);
4391   outb(0x1f4, (sector >> 8) & 0xff);
4392   outb(0x1f5, (sector >> 16) & 0xff);
4393   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4394   if(b->flags & B_DIRTY){
4395     outb(0x1f7, write_cmd);
4396     outsl(0x1f0, b->data, BSIZE/4);
4397   } else {
4398     outb(0x1f7, read_cmd);
4399   }
4400 }
4401 
4402 
4403 void
4404 ideintr(void)
4405 {
4406   struct buf *b;
4407 
4408   
4409   acquire(&idelock);
4410 
4411   if((b = idequeue) == 0){
4412     release(&idelock);
4413     return;
4414   }
4415   idequeue = b->qnext;
4416 
4417   
4418   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4419     insl(0x1f0, b->data, BSIZE/4);
4420 
4421   
4422   b->flags |= B_VALID;
4423   b->flags &= ~B_DIRTY;
4424   wakeup(b);
4425 
4426   
4427   if(idequeue != 0)
4428     idestart(idequeue);
4429 
4430   release(&idelock);
4431 }
4432 
4433 
4434 
4435 
4436 void
4437 iderw(struct buf *b)
4438 {
4439   struct buf **pp;
4440 
4441   if(!holdingsleep(&b->lock))
4442     panic("iderw: buf not locked");
4443   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4444     panic("iderw: nothing to do");
4445   if(b->dev != 0 && !havedisk1)
4446     panic("iderw: ide disk 1 not present");
4447 
4448   acquire(&idelock);  
4449 
4450   
4451   b->qnext = 0;
4452   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4453     ;
4454   *pp = b;
4455 
4456   
4457   if(idequeue == b)
4458     idestart(b);
4459 
4460   
4461   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4462     sleep(b, &idelock);
4463   }
4464 
4465 
4466   release(&idelock);
4467 }
4468 
4469 
4470 
4471 
4472 
4473 
4474 
4475 
4476 
4477 
4478 
4479 
4480 
4481 
4482 
4483 
4484 
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 
4504 
4505 
4506 
4507 
4508 
4509 
4510 
4511 
4512 
4513 
4514 
4515 
4516 
4517 
4518 
4519 
4520 #include "types.h"
4521 #include "defs.h"
4522 #include "param.h"
4523 #include "spinlock.h"
4524 #include "sleeplock.h"
4525 #include "fs.h"
4526 #include "buf.h"
4527 
4528 struct {
4529   struct spinlock lock;
4530   struct buf buf[NBUF];
4531 
4532   
4533   
4534   struct buf head;
4535 } bcache;
4536 
4537 void
4538 binit(void)
4539 {
4540   struct buf *b;
4541 
4542   initlock(&bcache.lock, "bcache");
4543 
4544   
4545   bcache.head.prev = &bcache.head;
4546   bcache.head.next = &bcache.head;
4547   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4548     b->next = bcache.head.next;
4549     b->prev = &bcache.head;
4550     initsleeplock(&b->lock, "buffer");
4551     bcache.head.next->prev = b;
4552     bcache.head.next = b;
4553   }
4554 }
4555 
4556 
4557 
4558 
4559 static struct buf*
4560 bget(uint dev, uint blockno)
4561 {
4562   struct buf *b;
4563 
4564   acquire(&bcache.lock);
4565 
4566   
4567   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4568     if(b->dev == dev && b->blockno == blockno){
4569       b->refcnt++;
4570       release(&bcache.lock);
4571       acquiresleep(&b->lock);
4572       return b;
4573     }
4574   }
4575 
4576   
4577   
4578   
4579   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4580     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4581       b->dev = dev;
4582       b->blockno = blockno;
4583       b->flags = 0;
4584       b->refcnt = 1;
4585       release(&bcache.lock);
4586       acquiresleep(&b->lock);
4587       return b;
4588     }
4589   }
4590   panic("bget: no buffers");
4591 }
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 struct buf*
4602 bread(uint dev, uint blockno)
4603 {
4604   struct buf *b;
4605 
4606   b = bget(dev, blockno);
4607   if((b->flags & B_VALID) == 0) {
4608     iderw(b);
4609   }
4610   return b;
4611 }
4612 
4613 
4614 void
4615 bwrite(struct buf *b)
4616 {
4617   if(!holdingsleep(&b->lock))
4618     panic("bwrite");
4619   b->flags |= B_DIRTY;
4620   iderw(b);
4621 }
4622 
4623 
4624 
4625 void
4626 brelse(struct buf *b)
4627 {
4628   if(!holdingsleep(&b->lock))
4629     panic("brelse");
4630 
4631   releasesleep(&b->lock);
4632 
4633   acquire(&bcache.lock);
4634   b->refcnt--;
4635   if (b->refcnt == 0) {
4636     
4637     b->next->prev = b->prev;
4638     b->prev->next = b->next;
4639     b->next = bcache.head.next;
4640     b->prev = &bcache.head;
4641     bcache.head.next->prev = b;
4642     bcache.head.next = b;
4643   }
4644 
4645   release(&bcache.lock);
4646 }
4647 
4648 
4649 
4650 
4651 
4652 #include "types.h"
4653 #include "defs.h"
4654 #include "param.h"
4655 #include "x86.h"
4656 #include "memlayout.h"
4657 #include "mmu.h"
4658 #include "proc.h"
4659 #include "spinlock.h"
4660 #include "sleeplock.h"
4661 
4662 void
4663 initsleeplock(struct sleeplock *lk, char *name)
4664 {
4665   initlock(&lk->lk, "sleep lock");
4666   lk->name = name;
4667   lk->locked = 0;
4668   lk->pid = 0;
4669 }
4670 
4671 void
4672 acquiresleep(struct sleeplock *lk)
4673 {
4674   acquire(&lk->lk);
4675   while (lk->locked) {
4676     sleep(lk, &lk->lk);
4677   }
4678   lk->locked = 1;
4679   lk->pid = myproc()->pid;
4680   release(&lk->lk);
4681 }
4682 
4683 void
4684 releasesleep(struct sleeplock *lk)
4685 {
4686   acquire(&lk->lk);
4687   lk->locked = 0;
4688   lk->pid = 0;
4689   wakeup(lk);
4690   release(&lk->lk);
4691 }
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 int
4701 holdingsleep(struct sleeplock *lk)
4702 {
4703   int r;
4704 
4705   acquire(&lk->lk);
4706   r = lk->locked && (lk->pid == myproc()->pid);
4707   release(&lk->lk);
4708   return r;
4709 }
4710 
4711 
4712 
4713 
4714 
4715 
4716 
4717 
4718 
4719 
4720 
4721 
4722 
4723 
4724 
4725 
4726 
4727 
4728 
4729 
4730 
4731 
4732 
4733 
4734 
4735 
4736 
4737 
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 #include "types.h"
4751 #include "defs.h"
4752 #include "param.h"
4753 #include "spinlock.h"
4754 #include "sleeplock.h"
4755 #include "fs.h"
4756 #include "buf.h"
4757 
4758 
4759 
4760 
4761 
4762 
4763 
4764 
4765 
4766 
4767 
4768 
4769 
4770 
4771 
4772 
4773 
4774 
4775 
4776 
4777 
4778 
4779 
4780 
4781 
4782 
4783 struct logheader {
4784   int n;
4785   int block[LOGSIZE];
4786 };
4787 
4788 struct log {
4789   struct spinlock lock;
4790   int start;
4791   int size;
4792   int outstanding; 
4793   int committing;  
4794   int dev;
4795   struct logheader lh;
4796 };
4797 
4798 
4799 
4800 struct log log;
4801 
4802 static void recover_from_log(void);
4803 static void commit();
4804 
4805 void
4806 initlog(int dev)
4807 {
4808   if (sizeof(struct logheader) >= BSIZE)
4809     panic("initlog: too big logheader");
4810 
4811   struct superblock sb;
4812   initlock(&log.lock, "log");
4813   readsb(dev, &sb);
4814   log.start = sb.logstart;
4815   log.size = sb.nlog;
4816   log.dev = dev;
4817   recover_from_log();
4818 }
4819 
4820 
4821 static void
4822 install_trans(void)
4823 {
4824   int tail;
4825 
4826   for (tail = 0; tail < log.lh.n; tail++) {
4827     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4828     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4829     memmove(dbuf->data, lbuf->data, BSIZE);  
4830     bwrite(dbuf);  
4831     brelse(lbuf);
4832     brelse(dbuf);
4833   }
4834 }
4835 
4836 
4837 static void
4838 read_head(void)
4839 {
4840   struct buf *buf = bread(log.dev, log.start);
4841   struct logheader *lh = (struct logheader *) (buf->data);
4842   int i;
4843   log.lh.n = lh->n;
4844   for (i = 0; i < log.lh.n; i++) {
4845     log.lh.block[i] = lh->block[i];
4846   }
4847   brelse(buf);
4848 }
4849 
4850 
4851 
4852 
4853 static void
4854 write_head(void)
4855 {
4856   struct buf *buf = bread(log.dev, log.start);
4857   struct logheader *hb = (struct logheader *) (buf->data);
4858   int i;
4859   hb->n = log.lh.n;
4860   for (i = 0; i < log.lh.n; i++) {
4861     hb->block[i] = log.lh.block[i];
4862   }
4863   bwrite(buf);
4864   brelse(buf);
4865 }
4866 
4867 static void
4868 recover_from_log(void)
4869 {
4870   read_head();
4871   install_trans(); 
4872   log.lh.n = 0;
4873   write_head(); 
4874 }
4875 
4876 
4877 void
4878 begin_op(void)
4879 {
4880   acquire(&log.lock);
4881   while(1){
4882     if(log.committing){
4883       sleep(&log, &log.lock);
4884     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4885       
4886       sleep(&log, &log.lock);
4887     } else {
4888       log.outstanding += 1;
4889       release(&log.lock);
4890       break;
4891     }
4892   }
4893 }
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 void
4903 end_op(void)
4904 {
4905   int do_commit = 0;
4906 
4907   acquire(&log.lock);
4908   log.outstanding -= 1;
4909   if(log.committing)
4910     panic("log.committing");
4911   if(log.outstanding == 0){
4912     do_commit = 1;
4913     log.committing = 1;
4914   } else {
4915     
4916     
4917     
4918     wakeup(&log);
4919   }
4920   release(&log.lock);
4921 
4922   if(do_commit){
4923     
4924     
4925     commit();
4926     acquire(&log.lock);
4927     log.committing = 0;
4928     wakeup(&log);
4929     release(&log.lock);
4930   }
4931 }
4932 
4933 
4934 static void
4935 write_log(void)
4936 {
4937   int tail;
4938 
4939   for (tail = 0; tail < log.lh.n; tail++) {
4940     struct buf *to = bread(log.dev, log.start+tail+1); 
4941     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4942     memmove(to->data, from->data, BSIZE);
4943     bwrite(to);  
4944     brelse(from);
4945     brelse(to);
4946   }
4947 }
4948 
4949 
4950 static void
4951 commit()
4952 {
4953   if (log.lh.n > 0) {
4954     write_log();     
4955     write_head();    
4956     install_trans(); 
4957     log.lh.n = 0;
4958     write_head();    
4959   }
4960 }
4961 
4962 
4963 
4964 
4965 
4966 
4967 
4968 
4969 
4970 
4971 void
4972 log_write(struct buf *b)
4973 {
4974   int i;
4975 
4976   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4977     panic("too big a transaction");
4978   if (log.outstanding < 1)
4979     panic("log_write outside of trans");
4980 
4981   acquire(&log.lock);
4982   for (i = 0; i < log.lh.n; i++) {
4983     if (log.lh.block[i] == b->blockno)   
4984       break;
4985   }
4986   log.lh.block[i] = b->blockno;
4987   if (i == log.lh.n)
4988     log.lh.n++;
4989   b->flags |= B_DIRTY; 
4990   release(&log.lock);
4991 }
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 
5002 
5003 
5004 
5005 
5006 
5007 
5008 
5009 
5010 
5011 #include "types.h"
5012 #include "defs.h"
5013 #include "param.h"
5014 #include "stat.h"
5015 #include "mmu.h"
5016 #include "proc.h"
5017 #include "spinlock.h"
5018 #include "sleeplock.h"
5019 #include "fs.h"
5020 #include "buf.h"
5021 #include "file.h"
5022 
5023 #define min(a, b) ((a) < (b) ? (a) : (b))
5024 static void itrunc(struct inode*);
5025 
5026 
5027 struct superblock sb;
5028 
5029 
5030 void
5031 readsb(int dev, struct superblock *sb)
5032 {
5033   struct buf *bp;
5034 
5035   bp = bread(dev, 1);
5036   memmove(sb, bp->data, sizeof(*sb));
5037   brelse(bp);
5038 }
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 static void
5052 bzero(int dev, int bno)
5053 {
5054   struct buf *bp;
5055 
5056   bp = bread(dev, bno);
5057   memset(bp->data, 0, BSIZE);
5058   log_write(bp);
5059   brelse(bp);
5060 }
5061 
5062 
5063 
5064 
5065 static uint
5066 balloc(uint dev)
5067 {
5068   int b, bi, m;
5069   struct buf *bp;
5070 
5071   bp = 0;
5072   for(b = 0; b < sb.size; b += BPB){
5073     bp = bread(dev, BBLOCK(b, sb));
5074     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5075       m = 1 << (bi % 8);
5076       if((bp->data[bi/8] & m) == 0){  
5077         bp->data[bi/8] |= m;  
5078         log_write(bp);
5079         brelse(bp);
5080         bzero(dev, b + bi);
5081         return b + bi;
5082       }
5083     }
5084     brelse(bp);
5085   }
5086   panic("balloc: out of blocks");
5087 }
5088 
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 static void
5102 bfree(int dev, uint b)
5103 {
5104   struct buf *bp;
5105   int bi, m;
5106 
5107   bp = bread(dev, BBLOCK(b, sb));
5108   bi = b % BPB;
5109   m = 1 << (bi % 8);
5110   if((bp->data[bi/8] & m) == 0)
5111     panic("freeing free block");
5112   bp->data[bi/8] &= ~m;
5113   log_write(bp);
5114   brelse(bp);
5115 }
5116 
5117 
5118 
5119 
5120 
5121 
5122 
5123 
5124 
5125 
5126 
5127 
5128 
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 
5155 
5156 
5157 
5158 
5159 
5160 
5161 
5162 
5163 
5164 
5165 
5166 
5167 
5168 
5169 
5170 
5171 
5172 
5173 
5174 
5175 
5176 
5177 
5178 
5179 
5180 
5181 
5182 
5183 
5184 
5185 
5186 struct {
5187   struct spinlock lock;
5188   struct inode inode[NINODE];
5189 } icache;
5190 
5191 void
5192 iinit(int dev)
5193 {
5194   int i = 0;
5195 
5196   initlock(&icache.lock, "icache");
5197   for(i = 0; i < NINODE; i++) {
5198     initsleeplock(&icache.inode[i].lock, "inode");
5199   }
5200   readsb(dev, &sb);
5201   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5202  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5203           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5204           sb.bmapstart);
5205 }
5206 
5207 static struct inode* iget(uint dev, uint inum);
5208 
5209 
5210 
5211 
5212 struct inode*
5213 ialloc(uint dev, short type)
5214 {
5215   int inum;
5216   struct buf *bp;
5217   struct dinode *dip;
5218 
5219   for(inum = 1; inum < sb.ninodes; inum++){
5220     bp = bread(dev, IBLOCK(inum, sb));
5221     dip = (struct dinode*)bp->data + inum%IPB;
5222     if(dip->type == 0){  
5223       memset(dip, 0, sizeof(*dip));
5224       dip->type = type;
5225       log_write(bp);   
5226       brelse(bp);
5227       return iget(dev, inum);
5228     }
5229     brelse(bp);
5230   }
5231   panic("ialloc: no inodes");
5232 }
5233 
5234 
5235 
5236 
5237 
5238 void
5239 iupdate(struct inode *ip)
5240 {
5241   struct buf *bp;
5242   struct dinode *dip;
5243 
5244   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5245   dip = (struct dinode*)bp->data + ip->inum%IPB;
5246   dip->type = ip->type;
5247   dip->major = ip->major;
5248   dip->minor = ip->minor;
5249   dip->nlink = ip->nlink;
5250   dip->size = ip->size;
5251   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5252   log_write(bp);
5253   brelse(bp);
5254 }
5255 
5256 
5257 
5258 
5259 static struct inode*
5260 iget(uint dev, uint inum)
5261 {
5262   struct inode *ip, *empty;
5263 
5264   acquire(&icache.lock);
5265 
5266   
5267   empty = 0;
5268   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5269     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5270       ip->ref++;
5271       release(&icache.lock);
5272       return ip;
5273     }
5274     if(empty == 0 && ip->ref == 0)    
5275       empty = ip;
5276   }
5277 
5278   
5279   if(empty == 0)
5280     panic("iget: no inodes");
5281 
5282   ip = empty;
5283   ip->dev = dev;
5284   ip->inum = inum;
5285   ip->ref = 1;
5286   ip->valid = 0;
5287   release(&icache.lock);
5288 
5289   return ip;
5290 }
5291 
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 
5302 struct inode*
5303 idup(struct inode *ip)
5304 {
5305   acquire(&icache.lock);
5306   ip->ref++;
5307   release(&icache.lock);
5308   return ip;
5309 }
5310 
5311 
5312 
5313 void
5314 ilock(struct inode *ip)
5315 {
5316   struct buf *bp;
5317   struct dinode *dip;
5318 
5319   if(ip == 0 || ip->ref < 1)
5320     panic("ilock");
5321 
5322   acquiresleep(&ip->lock);
5323 
5324   if(ip->valid == 0){
5325     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5326     dip = (struct dinode*)bp->data + ip->inum%IPB;
5327     ip->type = dip->type;
5328     ip->major = dip->major;
5329     ip->minor = dip->minor;
5330     ip->nlink = dip->nlink;
5331     ip->size = dip->size;
5332     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5333     brelse(bp);
5334     ip->valid = 1;
5335     if(ip->type == 0)
5336       panic("ilock: no type");
5337   }
5338 }
5339 
5340 
5341 void
5342 iunlock(struct inode *ip)
5343 {
5344   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5345     panic("iunlock");
5346 
5347   releasesleep(&ip->lock);
5348 }
5349 
5350 
5351 
5352 
5353 
5354 
5355 
5356 
5357 void
5358 iput(struct inode *ip)
5359 {
5360   acquiresleep(&ip->lock);
5361   if(ip->valid && ip->nlink == 0){
5362     acquire(&icache.lock);
5363     int r = ip->ref;
5364     release(&icache.lock);
5365     if(r == 1){
5366       
5367       itrunc(ip);
5368       ip->type = 0;
5369       iupdate(ip);
5370       ip->valid = 0;
5371     }
5372   }
5373   releasesleep(&ip->lock);
5374 
5375   acquire(&icache.lock);
5376   ip->ref--;
5377   release(&icache.lock);
5378 }
5379 
5380 
5381 void
5382 iunlockput(struct inode *ip)
5383 {
5384   iunlock(ip);
5385   iput(ip);
5386 }
5387 
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 
5403 
5404 
5405 
5406 
5407 
5408 
5409 static uint
5410 bmap(struct inode *ip, uint bn)
5411 {
5412   uint addr, *a;
5413   struct buf *bp;
5414 
5415   if(bn < NDIRECT){
5416     if((addr = ip->addrs[bn]) == 0)
5417       ip->addrs[bn] = addr = balloc(ip->dev);
5418     return addr;
5419   }
5420   bn -= NDIRECT;
5421 
5422   if(bn < NINDIRECT){
5423     
5424     if((addr = ip->addrs[NDIRECT]) == 0)
5425       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5426     bp = bread(ip->dev, addr);
5427     a = (uint*)bp->data;
5428     if((addr = a[bn]) == 0){
5429       a[bn] = addr = balloc(ip->dev);
5430       log_write(bp);
5431     }
5432     brelse(bp);
5433     return addr;
5434   }
5435 
5436   panic("bmap: out of range");
5437 }
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 
5454 
5455 static void
5456 itrunc(struct inode *ip)
5457 {
5458   int i, j;
5459   struct buf *bp;
5460   uint *a;
5461 
5462   for(i = 0; i < NDIRECT; i++){
5463     if(ip->addrs[i]){
5464       bfree(ip->dev, ip->addrs[i]);
5465       ip->addrs[i] = 0;
5466     }
5467   }
5468 
5469   if(ip->addrs[NDIRECT]){
5470     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5471     a = (uint*)bp->data;
5472     for(j = 0; j < NINDIRECT; j++){
5473       if(a[j])
5474         bfree(ip->dev, a[j]);
5475     }
5476     brelse(bp);
5477     bfree(ip->dev, ip->addrs[NDIRECT]);
5478     ip->addrs[NDIRECT] = 0;
5479   }
5480 
5481   ip->size = 0;
5482   iupdate(ip);
5483 }
5484 
5485 
5486 
5487 void
5488 stati(struct inode *ip, struct stat *st)
5489 {
5490   st->dev = ip->dev;
5491   st->ino = ip->inum;
5492   st->type = ip->type;
5493   st->nlink = ip->nlink;
5494   st->size = ip->size;
5495 }
5496 
5497 
5498 
5499 
5500 
5501 
5502 int
5503 readi(struct inode *ip, char *dst, uint off, uint n)
5504 {
5505   uint tot, m;
5506   struct buf *bp;
5507 
5508   if(ip->type == T_DEV){
5509     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5510       return -1;
5511     return devsw[ip->major].read(ip, dst, n);
5512   }
5513 
5514   if(off > ip->size || off + n < off)
5515     return -1;
5516   if(off + n > ip->size)
5517     n = ip->size - off;
5518 
5519   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5520     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5521     m = min(n - tot, BSIZE - off%BSIZE);
5522     memmove(dst, bp->data + off%BSIZE, m);
5523     brelse(bp);
5524   }
5525   return n;
5526 }
5527 
5528 
5529 
5530 int
5531 writei(struct inode *ip, char *src, uint off, uint n)
5532 {
5533   uint tot, m;
5534   struct buf *bp;
5535 
5536   if(ip->type == T_DEV){
5537     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5538       return -1;
5539     return devsw[ip->major].write(ip, src, n);
5540   }
5541 
5542   if(off > ip->size || off + n < off)
5543     return -1;
5544   if(off + n > MAXFILE*BSIZE)
5545     return -1;
5546 
5547 
5548 
5549 
5550   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5551     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5552     m = min(n - tot, BSIZE - off%BSIZE);
5553     memmove(bp->data + off%BSIZE, src, m);
5554     log_write(bp);
5555     brelse(bp);
5556   }
5557 
5558   if(n > 0 && off > ip->size){
5559     ip->size = off;
5560     iupdate(ip);
5561   }
5562   return n;
5563 }
5564 
5565 
5566 
5567 int
5568 namecmp(const char *s, const char *t)
5569 {
5570   return strncmp(s, t, DIRSIZ);
5571 }
5572 
5573 
5574 
5575 struct inode*
5576 dirlookup(struct inode *dp, char *name, uint *poff)
5577 {
5578   uint off, inum;
5579   struct dirent de;
5580 
5581   if(dp->type != T_DIR)
5582     panic("dirlookup not DIR");
5583 
5584   for(off = 0; off < dp->size; off += sizeof(de)){
5585     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5586       panic("dirlookup read");
5587     if(de.inum == 0)
5588       continue;
5589     if(namecmp(name, de.name) == 0){
5590       
5591       if(poff)
5592         *poff = off;
5593       inum = de.inum;
5594       return iget(dp->dev, inum);
5595     }
5596   }
5597 
5598   return 0;
5599 }
5600 
5601 int
5602 dirlink(struct inode *dp, char *name, uint inum)
5603 {
5604   int off;
5605   struct dirent de;
5606   struct inode *ip;
5607 
5608   
5609   if((ip = dirlookup(dp, name, 0)) != 0){
5610     iput(ip);
5611     return -1;
5612   }
5613 
5614   
5615   for(off = 0; off < dp->size; off += sizeof(de)){
5616     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5617       panic("dirlink read");
5618     if(de.inum == 0)
5619       break;
5620   }
5621 
5622   strncpy(de.name, name, DIRSIZ);
5623   de.inum = inum;
5624   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5625     panic("dirlink");
5626 
5627   return 0;
5628 }
5629 
5630 
5631 
5632 
5633 
5634 
5635 
5636 
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 static char*
5645 skipelem(char *path, char *name)
5646 {
5647   char *s;
5648   int len;
5649 
5650   while(*path == '/')
5651     path++;
5652   if(*path == 0)
5653     return 0;
5654   s = path;
5655   while(*path != '/' && *path != 0)
5656     path++;
5657   len = path - s;
5658   if(len >= DIRSIZ)
5659     memmove(name, s, DIRSIZ);
5660   else {
5661     memmove(name, s, len);
5662     name[len] = 0;
5663   }
5664   while(*path == '/')
5665     path++;
5666   return path;
5667 }
5668 
5669 
5670 
5671 
5672 
5673 static struct inode*
5674 namex(char *path, int nameiparent, char *name)
5675 {
5676   struct inode *ip, *next;
5677 
5678   if(*path == '/')
5679     ip = iget(ROOTDEV, ROOTINO);
5680   else
5681     ip = idup(myproc()->cwd);
5682 
5683   while((path = skipelem(path, name)) != 0){
5684     ilock(ip);
5685     if(ip->type != T_DIR){
5686       iunlockput(ip);
5687       return 0;
5688     }
5689     if(nameiparent && *path == '\0'){
5690       
5691       iunlock(ip);
5692       return ip;
5693     }
5694     if((next = dirlookup(ip, name, 0)) == 0){
5695       iunlockput(ip);
5696       return 0;
5697     }
5698     iunlockput(ip);
5699     ip = next;
5700   }
5701   if(nameiparent){
5702     iput(ip);
5703     return 0;
5704   }
5705   return ip;
5706 }
5707 
5708 struct inode*
5709 namei(char *path)
5710 {
5711   char name[DIRSIZ];
5712   return namex(path, 0, name);
5713 }
5714 
5715 struct inode*
5716 nameiparent(char *path, char *name)
5717 {
5718   return namex(path, 1, name);
5719 }
5720 
5721 
5722 
5723 
5724 
5725 
5726 
5727 
5728 
5729 
5730 
5731 
5732 
5733 
5734 
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 
5752 
5753 
5754 #include "types.h"
5755 #include "defs.h"
5756 #include "param.h"
5757 #include "fs.h"
5758 #include "spinlock.h"
5759 #include "sleeplock.h"
5760 #include "file.h"
5761 
5762 struct devsw devsw[NDEV];
5763 struct {
5764   struct spinlock lock;
5765   struct file file[NFILE];
5766 } ftable;
5767 
5768 void
5769 fileinit(void)
5770 {
5771   initlock(&ftable.lock, "ftable");
5772 }
5773 
5774 
5775 struct file*
5776 filealloc(void)
5777 {
5778   struct file *f;
5779 
5780   acquire(&ftable.lock);
5781   for(f = ftable.file; f < ftable.file + NFILE; f++){
5782     if(f->ref == 0){
5783       f->ref = 1;
5784       release(&ftable.lock);
5785       return f;
5786     }
5787   }
5788   release(&ftable.lock);
5789   return 0;
5790 }
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 struct file*
5802 filedup(struct file *f)
5803 {
5804   acquire(&ftable.lock);
5805   if(f->ref < 1)
5806     panic("filedup");
5807   f->ref++;
5808   release(&ftable.lock);
5809   return f;
5810 }
5811 
5812 
5813 void
5814 fileclose(struct file *f)
5815 {
5816   struct file ff;
5817 
5818   acquire(&ftable.lock);
5819   if(f->ref < 1)
5820     panic("fileclose");
5821   if(--f->ref > 0){
5822     release(&ftable.lock);
5823     return;
5824   }
5825   ff = *f;
5826   f->ref = 0;
5827   f->type = FD_NONE;
5828   release(&ftable.lock);
5829 
5830   if(ff.type == FD_PIPE)
5831     pipeclose(ff.pipe, ff.writable);
5832   else if(ff.type == FD_INODE){
5833     begin_op();
5834     iput(ff.ip);
5835     end_op();
5836   }
5837 }
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 int
5852 filestat(struct file *f, struct stat *st)
5853 {
5854   if(f->type == FD_INODE){
5855     ilock(f->ip);
5856     stati(f->ip, st);
5857     iunlock(f->ip);
5858     return 0;
5859   }
5860   return -1;
5861 }
5862 
5863 
5864 int
5865 fileread(struct file *f, char *addr, int n)
5866 {
5867   int r;
5868 
5869   if(f->readable == 0)
5870     return -1;
5871   if(f->type == FD_PIPE)
5872     return piperead(f->pipe, addr, n);
5873   if(f->type == FD_INODE){
5874     ilock(f->ip);
5875     if((r = readi(f->ip, addr, f->off, n)) > 0)
5876       f->off += r;
5877     iunlock(f->ip);
5878     return r;
5879   }
5880   panic("fileread");
5881 }
5882 
5883 
5884 int
5885 filewrite(struct file *f, char *addr, int n)
5886 {
5887   int r;
5888 
5889   if(f->writable == 0)
5890     return -1;
5891   if(f->type == FD_PIPE)
5892     return pipewrite(f->pipe, addr, n);
5893   if(f->type == FD_INODE){
5894     
5895     
5896     
5897     
5898     
5899     
5900     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
5901     int i = 0;
5902     while(i < n){
5903       int n1 = n - i;
5904       if(n1 > max)
5905         n1 = max;
5906 
5907       begin_op();
5908       ilock(f->ip);
5909       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5910         f->off += r;
5911       iunlock(f->ip);
5912       end_op();
5913 
5914       if(r < 0)
5915         break;
5916       if(r != n1)
5917         panic("short filewrite");
5918       i += r;
5919     }
5920     return i == n ? n : -1;
5921   }
5922   panic("filewrite");
5923 }
5924 
5925 
5926 
5927 
5928 
5929 
5930 
5931 
5932 
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 
5953 
5954 
5955 
5956 #include "types.h"
5957 #include "defs.h"
5958 #include "param.h"
5959 #include "stat.h"
5960 #include "mmu.h"
5961 #include "proc.h"
5962 #include "fs.h"
5963 #include "spinlock.h"
5964 #include "sleeplock.h"
5965 #include "file.h"
5966 #include "fcntl.h"
5967 
5968 
5969 
5970 static int
5971 argfd(int n, int *pfd, struct file **pf)
5972 {
5973   int fd;
5974   struct file *f;
5975 
5976   if(argint(n, &fd) < 0)
5977     return -1;
5978   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
5979     return -1;
5980   if(pfd)
5981     *pfd = fd;
5982   if(pf)
5983     *pf = f;
5984   return 0;
5985 }
5986 
5987 
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 
6002 static int
6003 fdalloc(struct file *f)
6004 {
6005   int fd;
6006   struct proc *curproc = myproc();
6007 
6008   for(fd = 0; fd < NOFILE; fd++){
6009     if(curproc->ofile[fd] == 0){
6010       curproc->ofile[fd] = f;
6011       return fd;
6012     }
6013   }
6014   return -1;
6015 }
6016 
6017 int
6018 sys_dup(void)
6019 {
6020   struct file *f;
6021   int fd;
6022 
6023   if(argfd(0, 0, &f) < 0)
6024     return -1;
6025   if((fd=fdalloc(f)) < 0)
6026     return -1;
6027   filedup(f);
6028   return fd;
6029 }
6030 
6031 int
6032 sys_read(void)
6033 {
6034   struct file *f;
6035   int n;
6036   char *p;
6037 
6038   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6039     return -1;
6040   return fileread(f, p, n);
6041 }
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 int
6051 sys_write(void)
6052 {
6053   struct file *f;
6054   int n;
6055   char *p;
6056 
6057   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6058     return -1;
6059   return filewrite(f, p, n);
6060 }
6061 
6062 int
6063 sys_close(void)
6064 {
6065   int fd;
6066   struct file *f;
6067 
6068   if(argfd(0, &fd, &f) < 0)
6069     return -1;
6070   myproc()->ofile[fd] = 0;
6071   fileclose(f);
6072   return 0;
6073 }
6074 
6075 int
6076 sys_fstat(void)
6077 {
6078   struct file *f;
6079   struct stat *st;
6080 
6081   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6082     return -1;
6083   return filestat(f, st);
6084 }
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 int
6102 sys_link(void)
6103 {
6104   char name[DIRSIZ], *new, *old;
6105   struct inode *dp, *ip;
6106 
6107   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6108     return -1;
6109 
6110   begin_op();
6111   if((ip = namei(old)) == 0){
6112     end_op();
6113     return -1;
6114   }
6115 
6116   ilock(ip);
6117   if(ip->type == T_DIR){
6118     iunlockput(ip);
6119     end_op();
6120     return -1;
6121   }
6122 
6123   ip->nlink++;
6124   iupdate(ip);
6125   iunlock(ip);
6126 
6127   if((dp = nameiparent(new, name)) == 0)
6128     goto bad;
6129   ilock(dp);
6130   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6131     iunlockput(dp);
6132     goto bad;
6133   }
6134   iunlockput(dp);
6135   iput(ip);
6136 
6137   end_op();
6138 
6139   return 0;
6140 
6141 bad:
6142   ilock(ip);
6143   ip->nlink--;
6144   iupdate(ip);
6145   iunlockput(ip);
6146   end_op();
6147   return -1;
6148 }
6149 
6150 
6151 static int
6152 isdirempty(struct inode *dp)
6153 {
6154   int off;
6155   struct dirent de;
6156 
6157   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6158     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6159       panic("isdirempty: readi");
6160     if(de.inum != 0)
6161       return 0;
6162   }
6163   return 1;
6164 }
6165 
6166 int
6167 sys_unlink(void)
6168 {
6169   struct inode *ip, *dp;
6170   struct dirent de;
6171   char name[DIRSIZ], *path;
6172   uint off;
6173 
6174   if(argstr(0, &path) < 0)
6175     return -1;
6176 
6177   begin_op();
6178   if((dp = nameiparent(path, name)) == 0){
6179     end_op();
6180     return -1;
6181   }
6182 
6183   ilock(dp);
6184 
6185   
6186   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6187     goto bad;
6188 
6189   if((ip = dirlookup(dp, name, &off)) == 0)
6190     goto bad;
6191   ilock(ip);
6192 
6193   if(ip->nlink < 1)
6194     panic("unlink: nlink < 1");
6195   if(ip->type == T_DIR && !isdirempty(ip)){
6196     iunlockput(ip);
6197     goto bad;
6198   }
6199 
6200   memset(&de, 0, sizeof(de));
6201   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6202     panic("unlink: writei");
6203   if(ip->type == T_DIR){
6204     dp->nlink--;
6205     iupdate(dp);
6206   }
6207   iunlockput(dp);
6208 
6209   ip->nlink--;
6210   iupdate(ip);
6211   iunlockput(ip);
6212 
6213   end_op();
6214 
6215   return 0;
6216 
6217 bad:
6218   iunlockput(dp);
6219   end_op();
6220   return -1;
6221 }
6222 
6223 static struct inode*
6224 create(char *path, short type, short major, short minor)
6225 {
6226   struct inode *ip, *dp;
6227   char name[DIRSIZ];
6228 
6229   if((dp = nameiparent(path, name)) == 0)
6230     return 0;
6231   ilock(dp);
6232 
6233   if((ip = dirlookup(dp, name, 0)) != 0){
6234     iunlockput(dp);
6235     ilock(ip);
6236     if(type == T_FILE && ip->type == T_FILE)
6237       return ip;
6238     iunlockput(ip);
6239     return 0;
6240   }
6241 
6242   if((ip = ialloc(dp->dev, type)) == 0)
6243     panic("create: ialloc");
6244 
6245   ilock(ip);
6246   ip->major = major;
6247   ip->minor = minor;
6248   ip->nlink = 1;
6249   iupdate(ip);
6250   if(type == T_DIR){  
6251     dp->nlink++;  
6252     iupdate(dp);
6253     
6254     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6255       panic("create dots");
6256   }
6257 
6258   if(dirlink(dp, name, ip->inum) < 0)
6259     panic("create: dirlink");
6260 
6261   iunlockput(dp);
6262 
6263   return ip;
6264 }
6265 
6266 int
6267 sys_open(void)
6268 {
6269   char *path;
6270   int fd, omode;
6271   struct file *f;
6272   struct inode *ip;
6273 
6274   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6275     return -1;
6276 
6277   begin_op();
6278 
6279   if(omode & O_CREATE){
6280     ip = create(path, T_FILE, 0, 0);
6281     if(ip == 0){
6282       end_op();
6283       return -1;
6284     }
6285   } else {
6286     if((ip = namei(path)) == 0){
6287       end_op();
6288       return -1;
6289     }
6290     ilock(ip);
6291     if(ip->type == T_DIR && omode != O_RDONLY){
6292       iunlockput(ip);
6293       end_op();
6294       return -1;
6295     }
6296   }
6297 
6298 
6299 
6300   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6301     if(f)
6302       fileclose(f);
6303     iunlockput(ip);
6304     end_op();
6305     return -1;
6306   }
6307   iunlock(ip);
6308   end_op();
6309 
6310   f->type = FD_INODE;
6311   f->ip = ip;
6312   f->off = 0;
6313   f->readable = !(omode & O_WRONLY);
6314   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6315   return fd;
6316 }
6317 
6318 int
6319 sys_mkdir(void)
6320 {
6321   char *path;
6322   struct inode *ip;
6323 
6324   begin_op();
6325   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6326     end_op();
6327     return -1;
6328   }
6329   iunlockput(ip);
6330   end_op();
6331   return 0;
6332 }
6333 
6334 int
6335 sys_mknod(void)
6336 {
6337   struct inode *ip;
6338   char *path;
6339   int major, minor;
6340 
6341   begin_op();
6342   if((argstr(0, &path)) < 0 ||
6343      argint(1, &major) < 0 ||
6344      argint(2, &minor) < 0 ||
6345      (ip = create(path, T_DEV, major, minor)) == 0){
6346     end_op();
6347     return -1;
6348   }
6349   iunlockput(ip);
6350   end_op();
6351   return 0;
6352 }
6353 
6354 int
6355 sys_chdir(void)
6356 {
6357   char *path;
6358   struct inode *ip;
6359   struct proc *curproc = myproc();
6360 
6361   begin_op();
6362   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6363     end_op();
6364     return -1;
6365   }
6366   ilock(ip);
6367   if(ip->type != T_DIR){
6368     iunlockput(ip);
6369     end_op();
6370     return -1;
6371   }
6372   iunlock(ip);
6373   iput(curproc->cwd);
6374   end_op();
6375   curproc->cwd = ip;
6376   return 0;
6377 }
6378 
6379 int
6380 sys_exec(void)
6381 {
6382   char *path, *argv[MAXARG];
6383   int i;
6384   uint uargv, uarg;
6385 
6386   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6387     return -1;
6388   }
6389   memset(argv, 0, sizeof(argv));
6390   for(i=0;; i++){
6391     if(i >= NELEM(argv))
6392       return -1;
6393     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6394       return -1;
6395     if(uarg == 0){
6396       argv[i] = 0;
6397       break;
6398     }
6399     if(fetchstr(uarg, &argv[i]) < 0)
6400       return -1;
6401   }
6402   return exec(path, argv);
6403 }
6404 
6405 int
6406 sys_pipe(void)
6407 {
6408   int *fd;
6409   struct file *rf, *wf;
6410   int fd0, fd1;
6411 
6412   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6413     return -1;
6414   if(pipealloc(&rf, &wf) < 0)
6415     return -1;
6416   fd0 = -1;
6417   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6418     if(fd0 >= 0)
6419       myproc()->ofile[fd0] = 0;
6420     fileclose(rf);
6421     fileclose(wf);
6422     return -1;
6423   }
6424   fd[0] = fd0;
6425   fd[1] = fd1;
6426   return 0;
6427 }
6428 
6429 
6430 
6431 
6432 
6433 
6434 
6435 
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 #include "types.h"
6451 #include "param.h"
6452 #include "memlayout.h"
6453 #include "mmu.h"
6454 #include "proc.h"
6455 #include "defs.h"
6456 #include "x86.h"
6457 #include "elf.h"
6458 
6459 int
6460 exec(char *path, char **argv)
6461 {
6462   char *s, *last;
6463   int i, off;
6464   uint argc, sz, sp, ustack[3+MAXARG+1];
6465   struct elfhdr elf;
6466   struct inode *ip;
6467   struct proghdr ph;
6468   pde_t *pgdir, *oldpgdir;
6469   struct proc *curproc = myproc();
6470 
6471   begin_op();
6472 
6473   if((ip = namei(path)) == 0){
6474     end_op();
6475     cprintf("exec: fail\n");
6476     return -1;
6477   }
6478   ilock(ip);
6479   pgdir = 0;
6480 
6481   
6482   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6483     goto bad;
6484   if(elf.magic != ELF_MAGIC)
6485     goto bad;
6486 
6487   if((pgdir = setupkvm()) == 0)
6488     goto bad;
6489 
6490   
6491   sz = 0;
6492   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6493     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6494       goto bad;
6495     if(ph.type != ELF_PROG_LOAD)
6496       continue;
6497     if(ph.memsz < ph.filesz)
6498       goto bad;
6499     if(ph.vaddr + ph.memsz < ph.vaddr)
6500       goto bad;
6501     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6502       goto bad;
6503     if(ph.vaddr % PGSIZE != 0)
6504       goto bad;
6505     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6506       goto bad;
6507   }
6508   iunlockput(ip);
6509   end_op();
6510   ip = 0;
6511 
6512   
6513   
6514   sz = PGROUNDUP(sz);
6515   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6516     goto bad;
6517   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6518   sp = sz;
6519 
6520   
6521   for(argc = 0; argv[argc]; argc++) {
6522     if(argc >= MAXARG)
6523       goto bad;
6524     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6525     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6526       goto bad;
6527     ustack[3+argc] = sp;
6528   }
6529   ustack[3+argc] = 0;
6530 
6531   ustack[0] = 0xffffffff;  
6532   ustack[1] = argc;
6533   ustack[2] = sp - (argc+1)*4;  
6534 
6535   sp -= (3+argc+1) * 4;
6536   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6537     goto bad;
6538 
6539   
6540   for(last=s=path; *s; s++)
6541     if(*s == '/')
6542       last = s+1;
6543   safestrcpy(curproc->name, last, sizeof(curproc->name));
6544 
6545   
6546   oldpgdir = curproc->pgdir;
6547   curproc->pgdir = pgdir;
6548   curproc->sz = sz;
6549   curproc->tf->eip = elf.entry;  
6550   curproc->tf->esp = sp;
6551   switchuvm(curproc);
6552   freevm(oldpgdir);
6553   return 0;
6554 
6555  bad:
6556   if(pgdir)
6557     freevm(pgdir);
6558   if(ip){
6559     iunlockput(ip);
6560     end_op();
6561   }
6562   return -1;
6563 }
6564 
6565 
6566 
6567 
6568 
6569 
6570 
6571 
6572 
6573 
6574 
6575 
6576 
6577 
6578 
6579 
6580 
6581 
6582 
6583 
6584 
6585 
6586 
6587 
6588 
6589 
6590 
6591 
6592 
6593 
6594 
6595 
6596 
6597 
6598 
6599 
6600 #include "types.h"
6601 #include "defs.h"
6602 #include "param.h"
6603 #include "mmu.h"
6604 #include "proc.h"
6605 #include "fs.h"
6606 #include "spinlock.h"
6607 #include "sleeplock.h"
6608 #include "file.h"
6609 
6610 #define PIPESIZE 512
6611 
6612 struct pipe {
6613   struct spinlock lock;
6614   char data[PIPESIZE];
6615   uint nread;     
6616   uint nwrite;    
6617   int readopen;   
6618   int writeopen;  
6619 };
6620 
6621 int
6622 pipealloc(struct file **f0, struct file **f1)
6623 {
6624   struct pipe *p;
6625 
6626   p = 0;
6627   *f0 = *f1 = 0;
6628   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6629     goto bad;
6630   if((p = (struct pipe*)kalloc()) == 0)
6631     goto bad;
6632   p->readopen = 1;
6633   p->writeopen = 1;
6634   p->nwrite = 0;
6635   p->nread = 0;
6636   initlock(&p->lock, "pipe");
6637   (*f0)->type = FD_PIPE;
6638   (*f0)->readable = 1;
6639   (*f0)->writable = 0;
6640   (*f0)->pipe = p;
6641   (*f1)->type = FD_PIPE;
6642   (*f1)->readable = 0;
6643   (*f1)->writable = 1;
6644   (*f1)->pipe = p;
6645   return 0;
6646 
6647 
6648 
6649 
6650  bad:
6651   if(p)
6652     kfree((char*)p);
6653   if(*f0)
6654     fileclose(*f0);
6655   if(*f1)
6656     fileclose(*f1);
6657   return -1;
6658 }
6659 
6660 void
6661 pipeclose(struct pipe *p, int writable)
6662 {
6663   acquire(&p->lock);
6664   if(writable){
6665     p->writeopen = 0;
6666     wakeup(&p->nread);
6667   } else {
6668     p->readopen = 0;
6669     wakeup(&p->nwrite);
6670   }
6671   if(p->readopen == 0 && p->writeopen == 0){
6672     release(&p->lock);
6673     kfree((char*)p);
6674   } else
6675     release(&p->lock);
6676 }
6677 
6678 int
6679 pipewrite(struct pipe *p, char *addr, int n)
6680 {
6681   int i;
6682 
6683   acquire(&p->lock);
6684   for(i = 0; i < n; i++){
6685     while(p->nwrite == p->nread + PIPESIZE){  
6686       if(p->readopen == 0 || myproc()->killed){
6687         release(&p->lock);
6688         return -1;
6689       }
6690       wakeup(&p->nread);
6691       sleep(&p->nwrite, &p->lock);  
6692     }
6693     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6694   }
6695   wakeup(&p->nread);  
6696   release(&p->lock);
6697   return n;
6698 }
6699 
6700 int
6701 piperead(struct pipe *p, char *addr, int n)
6702 {
6703   int i;
6704 
6705   acquire(&p->lock);
6706   while(p->nread == p->nwrite && p->writeopen){  
6707     if(myproc()->killed){
6708       release(&p->lock);
6709       return -1;
6710     }
6711     sleep(&p->nread, &p->lock); 
6712   }
6713   for(i = 0; i < n; i++){  
6714     if(p->nread == p->nwrite)
6715       break;
6716     addr[i] = p->data[p->nread++ % PIPESIZE];
6717   }
6718   wakeup(&p->nwrite);  
6719   release(&p->lock);
6720   return i;
6721 }
6722 
6723 
6724 
6725 
6726 
6727 
6728 
6729 
6730 
6731 
6732 
6733 
6734 
6735 
6736 
6737 
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 #include "types.h"
6751 #include "x86.h"
6752 
6753 void*
6754 memset(void *dst, int c, uint n)
6755 {
6756   if ((int)dst%4 == 0 && n%4 == 0){
6757     c &= 0xFF;
6758     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6759   } else
6760     stosb(dst, c, n);
6761   return dst;
6762 }
6763 
6764 int
6765 memcmp(const void *v1, const void *v2, uint n)
6766 {
6767   const uchar *s1, *s2;
6768 
6769   s1 = v1;
6770   s2 = v2;
6771   while(n-- > 0){
6772     if(*s1 != *s2)
6773       return *s1 - *s2;
6774     s1++, s2++;
6775   }
6776 
6777   return 0;
6778 }
6779 
6780 void*
6781 memmove(void *dst, const void *src, uint n)
6782 {
6783   const char *s;
6784   char *d;
6785 
6786   s = src;
6787   d = dst;
6788   if(s < d && s + n > d){
6789     s += n;
6790     d += n;
6791     while(n-- > 0)
6792       *--d = *--s;
6793   } else
6794     while(n-- > 0)
6795       *d++ = *s++;
6796 
6797   return dst;
6798 }
6799 
6800 
6801 void*
6802 memcpy(void *dst, const void *src, uint n)
6803 {
6804   return memmove(dst, src, n);
6805 }
6806 
6807 int
6808 strncmp(const char *p, const char *q, uint n)
6809 {
6810   while(n > 0 && *p && *p == *q)
6811     n--, p++, q++;
6812   if(n == 0)
6813     return 0;
6814   return (uchar)*p - (uchar)*q;
6815 }
6816 
6817 char*
6818 strncpy(char *s, const char *t, int n)
6819 {
6820   char *os;
6821 
6822   os = s;
6823   while(n-- > 0 && (*s++ = *t++) != 0)
6824     ;
6825   while(n-- > 0)
6826     *s++ = 0;
6827   return os;
6828 }
6829 
6830 
6831 char*
6832 safestrcpy(char *s, const char *t, int n)
6833 {
6834   char *os;
6835 
6836   os = s;
6837   if(n <= 0)
6838     return os;
6839   while(--n > 0 && (*s++ = *t++) != 0)
6840     ;
6841   *s = 0;
6842   return os;
6843 }
6844 
6845 
6846 
6847 
6848 
6849 
6850 int
6851 strlen(const char *s)
6852 {
6853   int n;
6854 
6855   for(n = 0; s[n]; n++)
6856     ;
6857   return n;
6858 }
6859 
6860 
6861 
6862 
6863 
6864 
6865 
6866 
6867 
6868 
6869 
6870 
6871 
6872 
6873 
6874 
6875 
6876 
6877 
6878 
6879 
6880 
6881 
6882 
6883 
6884 
6885 
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 
6901 
6902 struct mp {             
6903   uchar signature[4];           
6904   void *physaddr;               
6905   uchar length;                 
6906   uchar specrev;                
6907   uchar checksum;               
6908   uchar type;                   
6909   uchar imcrp;
6910   uchar reserved[3];
6911 };
6912 
6913 struct mpconf {         
6914   uchar signature[4];           
6915   ushort length;                
6916   uchar version;                
6917   uchar checksum;               
6918   uchar product[20];            
6919   uint *oemtable;               
6920   ushort oemlength;             
6921   ushort entry;                 
6922   uint *lapicaddr;              
6923   ushort xlength;               
6924   uchar xchecksum;              
6925   uchar reserved;
6926 };
6927 
6928 struct mpproc {         
6929   uchar type;                   
6930   uchar apicid;                 
6931   uchar version;                
6932   uchar flags;                  
6933     #define MPBOOT 0x02           
6934   uchar signature[4];           
6935   uint feature;                 
6936   uchar reserved[8];
6937 };
6938 
6939 struct mpioapic {       
6940   uchar type;                   
6941   uchar apicno;                 
6942   uchar version;                
6943   uchar flags;                  
6944   uint *addr;                  
6945 };
6946 
6947 
6948 
6949 
6950 
6951 #define MPPROC    0x00  
6952 #define MPBUS     0x01  
6953 #define MPIOAPIC  0x02  
6954 #define MPIOINTR  0x03  
6955 #define MPLINTR   0x04  
6956 
6957 
6958 
6959 
6960 
6961 
6962 
6963 
6964 
6965 
6966 
6967 
6968 
6969 
6970 
6971 
6972 
6973 
6974 
6975 
6976 
6977 
6978 
6979 
6980 
6981 
6982 
6983 
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 
7001 
7002 
7003 
7004 #include "types.h"
7005 #include "defs.h"
7006 #include "param.h"
7007 #include "memlayout.h"
7008 #include "mp.h"
7009 #include "x86.h"
7010 #include "mmu.h"
7011 #include "proc.h"
7012 
7013 struct cpu cpus[NCPU];
7014 int ncpu;
7015 uchar ioapicid;
7016 
7017 static uchar
7018 sum(uchar *addr, int len)
7019 {
7020   int i, sum;
7021 
7022   sum = 0;
7023   for(i=0; i<len; i++)
7024     sum += addr[i];
7025   return sum;
7026 }
7027 
7028 
7029 static struct mp*
7030 mpsearch1(uint a, int len)
7031 {
7032   uchar *e, *p, *addr;
7033 
7034   addr = P2V(a);
7035   e = addr+len;
7036   for(p = addr; p < e; p += sizeof(struct mp))
7037     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7038       return (struct mp*)p;
7039   return 0;
7040 }
7041 
7042 
7043 
7044 
7045 
7046 
7047 
7048 
7049 
7050 
7051 
7052 
7053 
7054 
7055 static struct mp*
7056 mpsearch(void)
7057 {
7058   uchar *bda;
7059   uint p;
7060   struct mp *mp;
7061 
7062   bda = (uchar *) P2V(0x400);
7063   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7064     if((mp = mpsearch1(p, 1024)))
7065       return mp;
7066   } else {
7067     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7068     if((mp = mpsearch1(p-1024, 1024)))
7069       return mp;
7070   }
7071   return mpsearch1(0xF0000, 0x10000);
7072 }
7073 
7074 
7075 
7076 
7077 
7078 
7079 static struct mpconf*
7080 mpconfig(struct mp **pmp)
7081 {
7082   struct mpconf *conf;
7083   struct mp *mp;
7084 
7085   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7086     return 0;
7087   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7088   if(memcmp(conf, "PCMP", 4) != 0)
7089     return 0;
7090   if(conf->version != 1 && conf->version != 4)
7091     return 0;
7092   if(sum((uchar*)conf, conf->length) != 0)
7093     return 0;
7094   *pmp = mp;
7095   return conf;
7096 }
7097 
7098 
7099 
7100 void
7101 mpinit(void)
7102 {
7103   uchar *p, *e;
7104   int ismp;
7105   struct mp *mp;
7106   struct mpconf *conf;
7107   struct mpproc *proc;
7108   struct mpioapic *ioapic;
7109 
7110   if((conf = mpconfig(&mp)) == 0)
7111     panic("Expect to run on an SMP");
7112   ismp = 1;
7113   lapic = (uint*)conf->lapicaddr;
7114   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7115     switch(*p){
7116     case MPPROC:
7117       proc = (struct mpproc*)p;
7118       if(ncpu < NCPU) {
7119         cpus[ncpu].apicid = proc->apicid;  
7120         ncpu++;
7121       }
7122       p += sizeof(struct mpproc);
7123       continue;
7124     case MPIOAPIC:
7125       ioapic = (struct mpioapic*)p;
7126       ioapicid = ioapic->apicno;
7127       p += sizeof(struct mpioapic);
7128       continue;
7129     case MPBUS:
7130     case MPIOINTR:
7131     case MPLINTR:
7132       p += 8;
7133       continue;
7134     default:
7135       ismp = 0;
7136       break;
7137     }
7138   }
7139   if(!ismp)
7140     panic("Didn't find a suitable machine");
7141 
7142   if(mp->imcrp){
7143     
7144     
7145     outb(0x22, 0x70);   
7146     outb(0x23, inb(0x23) | 1);  
7147   }
7148 }
7149 
7150 
7151 
7152 
7153 #include "param.h"
7154 #include "types.h"
7155 #include "defs.h"
7156 #include "date.h"
7157 #include "memlayout.h"
7158 #include "traps.h"
7159 #include "mmu.h"
7160 #include "x86.h"
7161 
7162 
7163 #define ID      (0x0020/4)   
7164 #define VER     (0x0030/4)   
7165 #define TPR     (0x0080/4)   
7166 #define EOI     (0x00B0/4)   
7167 #define SVR     (0x00F0/4)   
7168   #define ENABLE     0x00000100   
7169 #define ESR     (0x0280/4)   
7170 #define ICRLO   (0x0300/4)   
7171   #define INIT       0x00000500   
7172   #define STARTUP    0x00000600   
7173   #define DELIVS     0x00001000   
7174   #define ASSERT     0x00004000   
7175   #define DEASSERT   0x00000000
7176   #define LEVEL      0x00008000   
7177   #define BCAST      0x00080000   
7178   #define BUSY       0x00001000
7179   #define FIXED      0x00000000
7180 #define ICRHI   (0x0310/4)   
7181 #define TIMER   (0x0320/4)   
7182   #define X1         0x0000000B   
7183   #define PERIODIC   0x00020000   
7184 #define PCINT   (0x0340/4)   
7185 #define LINT0   (0x0350/4)   
7186 #define LINT1   (0x0360/4)   
7187 #define ERROR   (0x0370/4)   
7188   #define MASKED     0x00010000   
7189 #define TICR    (0x0380/4)   
7190 #define TCCR    (0x0390/4)   
7191 #define TDCR    (0x03E0/4)   
7192 
7193 volatile uint *lapic;  
7194 
7195 static void
7196 lapicw(int index, int value)
7197 {
7198   lapic[index] = value;
7199   lapic[ID];  
7200 }
7201 
7202 void
7203 lapicinit(void)
7204 {
7205   if(!lapic)
7206     return;
7207 
7208   
7209   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7210 
7211   
7212   
7213   
7214   
7215   lapicw(TDCR, X1);
7216   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7217   lapicw(TICR, 10000000);
7218 
7219   
7220   lapicw(LINT0, MASKED);
7221   lapicw(LINT1, MASKED);
7222 
7223   
7224   
7225   if(((lapic[VER]>>16) & 0xFF) >= 4)
7226     lapicw(PCINT, MASKED);
7227 
7228   
7229   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7230 
7231   
7232   lapicw(ESR, 0);
7233   lapicw(ESR, 0);
7234 
7235   
7236   lapicw(EOI, 0);
7237 
7238   
7239   lapicw(ICRHI, 0);
7240   lapicw(ICRLO, BCAST | INIT | LEVEL);
7241   while(lapic[ICRLO] & DELIVS)
7242     ;
7243 
7244   
7245   lapicw(TPR, 0);
7246 }
7247 
7248 
7249 
7250 int
7251 lapicid(void)
7252 {
7253   if (!lapic)
7254     return 0;
7255   return lapic[ID] >> 24;
7256 }
7257 
7258 
7259 void
7260 lapiceoi(void)
7261 {
7262   if(lapic)
7263     lapicw(EOI, 0);
7264 }
7265 
7266 
7267 
7268 void
7269 microdelay(int us)
7270 {
7271 }
7272 
7273 #define CMOS_PORT    0x70
7274 #define CMOS_RETURN  0x71
7275 
7276 
7277 
7278 void
7279 lapicstartap(uchar apicid, uint addr)
7280 {
7281   int i;
7282   ushort *wrv;
7283 
7284   
7285   
7286   
7287   outb(CMOS_PORT, 0xF);  
7288   outb(CMOS_PORT+1, 0x0A);
7289   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7290   wrv[0] = 0;
7291   wrv[1] = addr >> 4;
7292 
7293   
7294   
7295   lapicw(ICRHI, apicid<<24);
7296   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7297   microdelay(200);
7298   lapicw(ICRLO, INIT | LEVEL);
7299   microdelay(100);    
7300   
7301   
7302   
7303   
7304   
7305   for(i = 0; i < 2; i++){
7306     lapicw(ICRHI, apicid<<24);
7307     lapicw(ICRLO, STARTUP | (addr>>12));
7308     microdelay(200);
7309   }
7310 }
7311 
7312 #define CMOS_STATA   0x0a
7313 #define CMOS_STATB   0x0b
7314 #define CMOS_UIP    (1 << 7)        
7315 
7316 #define SECS    0x00
7317 #define MINS    0x02
7318 #define HOURS   0x04
7319 #define DAY     0x07
7320 #define MONTH   0x08
7321 #define YEAR    0x09
7322 
7323 static uint
7324 cmos_read(uint reg)
7325 {
7326   outb(CMOS_PORT,  reg);
7327   microdelay(200);
7328 
7329   return inb(CMOS_RETURN);
7330 }
7331 
7332 static void
7333 fill_rtcdate(struct rtcdate *r)
7334 {
7335   r->second = cmos_read(SECS);
7336   r->minute = cmos_read(MINS);
7337   r->hour   = cmos_read(HOURS);
7338   r->day    = cmos_read(DAY);
7339   r->month  = cmos_read(MONTH);
7340   r->year   = cmos_read(YEAR);
7341 }
7342 
7343 
7344 
7345 
7346 
7347 
7348 
7349 
7350 
7351 void
7352 cmostime(struct rtcdate *r)
7353 {
7354   struct rtcdate t1, t2;
7355   int sb, bcd;
7356 
7357   sb = cmos_read(CMOS_STATB);
7358 
7359   bcd = (sb & (1 << 2)) == 0;
7360 
7361   
7362   for(;;) {
7363     fill_rtcdate(&t1);
7364     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7365         continue;
7366     fill_rtcdate(&t2);
7367     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7368       break;
7369   }
7370 
7371   
7372   if(bcd) {
7373 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7374     CONV(second);
7375     CONV(minute);
7376     CONV(hour  );
7377     CONV(day   );
7378     CONV(month );
7379     CONV(year  );
7380 #undef     CONV
7381   }
7382 
7383   *r = t1;
7384   r->year += 2000;
7385 }
7386 
7387 
7388 
7389 
7390 
7391 
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 
7401 
7402 
7403 
7404 #include "types.h"
7405 #include "defs.h"
7406 #include "traps.h"
7407 
7408 #define IOAPIC  0xFEC00000   
7409 
7410 #define REG_ID     0x00  
7411 #define REG_VER    0x01  
7412 #define REG_TABLE  0x10  
7413 
7414 
7415 
7416 
7417 
7418 
7419 #define INT_DISABLED   0x00010000  
7420 #define INT_LEVEL      0x00008000  
7421 #define INT_ACTIVELOW  0x00002000  
7422 #define INT_LOGICAL    0x00000800  
7423 
7424 volatile struct ioapic *ioapic;
7425 
7426 
7427 struct ioapic {
7428   uint reg;
7429   uint pad[3];
7430   uint data;
7431 };
7432 
7433 static uint
7434 ioapicread(int reg)
7435 {
7436   ioapic->reg = reg;
7437   return ioapic->data;
7438 }
7439 
7440 static void
7441 ioapicwrite(int reg, uint data)
7442 {
7443   ioapic->reg = reg;
7444   ioapic->data = data;
7445 }
7446 
7447 
7448 
7449 
7450 void
7451 ioapicinit(void)
7452 {
7453   int i, id, maxintr;
7454 
7455   ioapic = (volatile struct ioapic*)IOAPIC;
7456   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7457   id = ioapicread(REG_ID) >> 24;
7458   if(id != ioapicid)
7459     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7460 
7461   
7462   
7463   for(i = 0; i <= maxintr; i++){
7464     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7465     ioapicwrite(REG_TABLE+2*i+1, 0);
7466   }
7467 }
7468 
7469 void
7470 ioapicenable(int irq, int cpunum)
7471 {
7472   
7473   
7474   
7475   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7476   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7477 }
7478 
7479 
7480 
7481 
7482 
7483 
7484 
7485 
7486 
7487 
7488 
7489 
7490 
7491 
7492 
7493 
7494 
7495 
7496 
7497 
7498 
7499 
7500 
7501 
7502 #define KBSTATP         0x64    
7503 #define KBS_DIB         0x01    
7504 #define KBDATAP         0x60    
7505 
7506 #define NO              0
7507 
7508 #define SHIFT           (1<<0)
7509 #define CTL             (1<<1)
7510 #define ALT             (1<<2)
7511 
7512 #define CAPSLOCK        (1<<3)
7513 #define NUMLOCK         (1<<4)
7514 #define SCROLLLOCK      (1<<5)
7515 
7516 #define E0ESC           (1<<6)
7517 
7518 
7519 #define KEY_HOME        0xE0
7520 #define KEY_END         0xE1
7521 #define KEY_UP          0xE2
7522 #define KEY_DN          0xE3
7523 #define KEY_LF          0xE4
7524 #define KEY_RT          0xE5
7525 #define KEY_PGUP        0xE6
7526 #define KEY_PGDN        0xE7
7527 #define KEY_INS         0xE8
7528 #define KEY_DEL         0xE9
7529 
7530 
7531 #define C(x) (x - '@')
7532 
7533 static uchar shiftcode[256] =
7534 {
7535   [0x1D] CTL,
7536   [0x2A] SHIFT,
7537   [0x36] SHIFT,
7538   [0x38] ALT,
7539   [0x9D] CTL,
7540   [0xB8] ALT
7541 };
7542 
7543 static uchar togglecode[256] =
7544 {
7545   [0x3A] CAPSLOCK,
7546   [0x45] NUMLOCK,
7547   [0x46] SCROLLLOCK
7548 };
7549 
7550 static uchar normalmap[256] =
7551 {
7552   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7553   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7554   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7555   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7556   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7557   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7558   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7559   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7560   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7561   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7562   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7563   [0x9C] '\n',      
7564   [0xB5] '/',       
7565   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7566   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7567   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7568   [0x97] KEY_HOME,  [0xCF] KEY_END,
7569   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7570 };
7571 
7572 static uchar shiftmap[256] =
7573 {
7574   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7575   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7576   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7577   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7578   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7579   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7580   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7581   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7582   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7583   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7584   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7585   [0x9C] '\n',      
7586   [0xB5] '/',       
7587   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7588   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7589   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7590   [0x97] KEY_HOME,  [0xCF] KEY_END,
7591   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7592 };
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 static uchar ctlmap[256] =
7601 {
7602   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7603   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7604   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7605   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7606   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7607   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7608   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7609   [0x9C] '\r',      
7610   [0xB5] C('/'),    
7611   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7612   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7613   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7614   [0x97] KEY_HOME,  [0xCF] KEY_END,
7615   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7616 };
7617 
7618 
7619 
7620 
7621 
7622 
7623 
7624 
7625 
7626 
7627 
7628 
7629 
7630 
7631 
7632 
7633 
7634 
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 #include "types.h"
7651 #include "x86.h"
7652 #include "defs.h"
7653 #include "kbd.h"
7654 
7655 int
7656 kbdgetc(void)
7657 {
7658   static uint shift;
7659   static uchar *charcode[4] = {
7660     normalmap, shiftmap, ctlmap, ctlmap
7661   };
7662   uint st, data, c;
7663 
7664   st = inb(KBSTATP);
7665   if((st & KBS_DIB) == 0)
7666     return -1;
7667   data = inb(KBDATAP);
7668 
7669   if(data == 0xE0){
7670     shift |= E0ESC;
7671     return 0;
7672   } else if(data & 0x80){
7673     
7674     data = (shift & E0ESC ? data : data & 0x7F);
7675     shift &= ~(shiftcode[data] | E0ESC);
7676     return 0;
7677   } else if(shift & E0ESC){
7678     
7679     data |= 0x80;
7680     shift &= ~E0ESC;
7681   }
7682 
7683   shift |= shiftcode[data];
7684   shift ^= togglecode[data];
7685   c = charcode[shift & (CTL | SHIFT)][data];
7686   if(shift & CAPSLOCK){
7687     if('a' <= c && c <= 'z')
7688       c += 'A' - 'a';
7689     else if('A' <= c && c <= 'Z')
7690       c += 'a' - 'A';
7691   }
7692   return c;
7693 }
7694 
7695 void
7696 kbdintr(void)
7697 {
7698   consoleintr(kbdgetc);
7699 }
7700 
7701 
7702 
7703 
7704 #include "types.h"
7705 #include "defs.h"
7706 #include "param.h"
7707 #include "traps.h"
7708 #include "spinlock.h"
7709 #include "sleeplock.h"
7710 #include "fs.h"
7711 #include "file.h"
7712 #include "memlayout.h"
7713 #include "mmu.h"
7714 #include "proc.h"
7715 #include "x86.h"
7716 
7717 static void consputc(int);
7718 
7719 static int panicked = 0;
7720 
7721 static struct {
7722   struct spinlock lock;
7723   int locking;
7724 } cons;
7725 
7726 static void
7727 printint(int xx, int base, int sign)
7728 {
7729   static char digits[] = "0123456789abcdef";
7730   char buf[16];
7731   int i;
7732   uint x;
7733 
7734   if(sign && (sign = xx < 0))
7735     x = -xx;
7736   else
7737     x = xx;
7738 
7739   i = 0;
7740   do{
7741     buf[i++] = digits[x % base];
7742   }while((x /= base) != 0);
7743 
7744   if(sign)
7745     buf[i++] = '-';
7746 
7747   while(--i >= 0)
7748     consputc(buf[i]);
7749 }
7750 
7751 void
7752 cprintf(char *fmt, ...)
7753 {
7754   int i, c, locking;
7755   uint *argp;
7756   char *s;
7757 
7758   locking = cons.locking;
7759   if(locking)
7760     acquire(&cons.lock);
7761 
7762   if (fmt == 0)
7763     panic("null fmt");
7764 
7765   argp = (uint*)(void*)(&fmt + 1);
7766   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7767     if(c != '%'){
7768       consputc(c);
7769       continue;
7770     }
7771     c = fmt[++i] & 0xff;
7772     if(c == 0)
7773       break;
7774     switch(c){
7775     case 'd':
7776       printint(*argp++, 10, 1);
7777       break;
7778     case 'x':
7779     case 'p':
7780       printint(*argp++, 16, 0);
7781       break;
7782     case 's':
7783       if((s = (char*)*argp++) == 0)
7784         s = "(null)";
7785       for(; *s; s++)
7786         consputc(*s);
7787       break;
7788     case '%':
7789       consputc('%');
7790       break;
7791     default:
7792       
7793       consputc('%');
7794       consputc(c);
7795       break;
7796     }
7797   }
7798 
7799 
7800   if(locking)
7801     release(&cons.lock);
7802 }
7803 
7804 void
7805 panic(char *s)
7806 {
7807   int i;
7808   uint pcs[10];
7809 
7810   cli();
7811   cons.locking = 0;
7812   
7813   cprintf("lapicid %d: panic: ", lapicid());
7814   cprintf(s);
7815   cprintf("\n");
7816   getcallerpcs(&s, pcs);
7817   for(i=0; i<10; i++)
7818     cprintf(" %p", pcs[i]);
7819   panicked = 1; 
7820   for(;;)
7821     ;
7822 }
7823 
7824 #define BACKSPACE 0x100
7825 #define CRTPORT 0x3d4
7826 static ushort *crt = (ushort*)P2V(0xb8000);  
7827 
7828 static void
7829 cgaputc(int c)
7830 {
7831   int pos;
7832 
7833   
7834   outb(CRTPORT, 14);
7835   pos = inb(CRTPORT+1) << 8;
7836   outb(CRTPORT, 15);
7837   pos |= inb(CRTPORT+1);
7838 
7839   if(c == '\n')
7840     pos += 80 - pos%80;
7841   else if(c == BACKSPACE){
7842     if(pos > 0) --pos;
7843   } else
7844     crt[pos++] = (c&0xff) | 0x0700;  
7845 
7846   if(pos < 0 || pos > 25*80)
7847     panic("pos under/overflow");
7848 
7849 
7850   if((pos/80) >= 24){  
7851     memmove(crt, crt+80, sizeof(crt[0])*23*80);
7852     pos -= 80;
7853     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
7854   }
7855 
7856   outb(CRTPORT, 14);
7857   outb(CRTPORT+1, pos>>8);
7858   outb(CRTPORT, 15);
7859   outb(CRTPORT+1, pos);
7860   crt[pos] = ' ' | 0x0700;
7861 }
7862 
7863 void
7864 consputc(int c)
7865 {
7866   if(panicked){
7867     cli();
7868     for(;;)
7869       ;
7870   }
7871 
7872   if(c == BACKSPACE){
7873     uartputc('\b'); uartputc(' '); uartputc('\b');
7874   } else
7875     uartputc(c);
7876   cgaputc(c);
7877 }
7878 
7879 #define INPUT_BUF 128
7880 struct {
7881   char buf[INPUT_BUF];
7882   uint r;  
7883   uint w;  
7884   uint e;  
7885 } input;
7886 
7887 #define C(x)  ((x)-'@')  
7888 
7889 void
7890 consoleintr(int (*getc)(void))
7891 {
7892   int c, doprocdump = 0;
7893 
7894   acquire(&cons.lock);
7895   while((c = getc()) >= 0){
7896     switch(c){
7897     case C('P'):  
7898       
7899       doprocdump = 1;
7900       break;
7901     case C('U'):  
7902       while(input.e != input.w &&
7903             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
7904         input.e--;
7905         consputc(BACKSPACE);
7906       }
7907       break;
7908     case C('H'): case '\x7f':  
7909       if(input.e != input.w){
7910         input.e--;
7911         consputc(BACKSPACE);
7912       }
7913       break;
7914     default:
7915       if(c != 0 && input.e-input.r < INPUT_BUF){
7916         c = (c == '\r') ? '\n' : c;
7917         input.buf[input.e++ % INPUT_BUF] = c;
7918         consputc(c);
7919         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
7920           input.w = input.e;
7921           wakeup(&input.r);
7922         }
7923       }
7924       break;
7925     }
7926   }
7927   release(&cons.lock);
7928   if(doprocdump) {
7929     procdump();  
7930   }
7931 }
7932 
7933 int
7934 consoleread(struct inode *ip, char *dst, int n)
7935 {
7936   uint target;
7937   int c;
7938 
7939   iunlock(ip);
7940   target = n;
7941   acquire(&cons.lock);
7942   while(n > 0){
7943     while(input.r == input.w){
7944       if(myproc()->killed){
7945         release(&cons.lock);
7946         ilock(ip);
7947         return -1;
7948       }
7949       sleep(&input.r, &cons.lock);
7950     }
7951     c = input.buf[input.r++ % INPUT_BUF];
7952     if(c == C('D')){  
7953       if(n < target){
7954         
7955         
7956         input.r--;
7957       }
7958       break;
7959     }
7960     *dst++ = c;
7961     --n;
7962     if(c == '\n')
7963       break;
7964   }
7965   release(&cons.lock);
7966   ilock(ip);
7967 
7968   return target - n;
7969 }
7970 
7971 int
7972 consolewrite(struct inode *ip, char *buf, int n)
7973 {
7974   int i;
7975 
7976   iunlock(ip);
7977   acquire(&cons.lock);
7978   for(i = 0; i < n; i++)
7979     consputc(buf[i] & 0xff);
7980   release(&cons.lock);
7981   ilock(ip);
7982 
7983   return n;
7984 }
7985 
7986 void
7987 consoleinit(void)
7988 {
7989   initlock(&cons.lock, "console");
7990 
7991   devsw[CONSOLE].write = consolewrite;
7992   devsw[CONSOLE].read = consoleread;
7993   cons.locking = 1;
7994 
7995   ioapicenable(IRQ_KBD, 0);
7996 }
7997 
7998 
7999 
8000 
8001 
8002 #include "types.h"
8003 #include "defs.h"
8004 #include "param.h"
8005 #include "traps.h"
8006 #include "spinlock.h"
8007 #include "sleeplock.h"
8008 #include "fs.h"
8009 #include "file.h"
8010 #include "mmu.h"
8011 #include "proc.h"
8012 #include "x86.h"
8013 
8014 #define COM1    0x3f8
8015 
8016 static int uart;    
8017 
8018 void
8019 uartinit(void)
8020 {
8021   char *p;
8022 
8023   
8024   outb(COM1+2, 0);
8025 
8026   
8027   outb(COM1+3, 0x80);    
8028   outb(COM1+0, 115200/9600);
8029   outb(COM1+1, 0);
8030   outb(COM1+3, 0x03);    
8031   outb(COM1+4, 0);
8032   outb(COM1+1, 0x01);    
8033 
8034   
8035   if(inb(COM1+5) == 0xFF)
8036     return;
8037   uart = 1;
8038 
8039   
8040   
8041   inb(COM1+2);
8042   inb(COM1+0);
8043   ioapicenable(IRQ_COM1, 0);
8044 
8045   
8046   for(p="xv6...\n"; *p; p++)
8047     uartputc(*p);
8048 }
8049 
8050 void
8051 uartputc(int c)
8052 {
8053   int i;
8054 
8055   if(!uart)
8056     return;
8057   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8058     microdelay(10);
8059   outb(COM1+0, c);
8060 }
8061 
8062 static int
8063 uartgetc(void)
8064 {
8065   if(!uart)
8066     return -1;
8067   if(!(inb(COM1+5) & 0x01))
8068     return -1;
8069   return inb(COM1+0);
8070 }
8071 
8072 void
8073 uartintr(void)
8074 {
8075   consoleintr(uartgetc);
8076 }
8077 
8078 
8079 
8080 
8081 
8082 
8083 
8084 
8085 
8086 
8087 
8088 
8089 
8090 
8091 
8092 
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 
8101 
8102 
8103 
8104 
8105 
8106 
8107 
8108 .globl start
8109 start:
8110   pushl $argv
8111   pushl $init
8112   pushl $0  
8113   movl $SYS_exec, %eax
8114   int $T_SYSCALL
8115 
8116 
8117 exit:
8118   movl $SYS_exit, %eax
8119   int $T_SYSCALL
8120   jmp exit
8121 
8122 
8123 init:
8124   .string "/init\0"
8125 
8126 
8127 .p2align 2
8128 argv:
8129   .long init
8130   .long 0
8131 
8132 
8133 
8134 
8135 
8136 
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 
8151 
8152 
8153 
8154   .globl name; \
8155   name: \
8156     movl $SYS_ 
8157     int $T_SYSCALL; \
8158     ret
8159 
8160 SYSCALL(fork)
8161 SYSCALL(exit)
8162 SYSCALL(wait)
8163 SYSCALL(waitx)
8164 SYSCALL(pipe)
8165 SYSCALL(read)
8166 SYSCALL(write)
8167 SYSCALL(close)
8168 SYSCALL(kill)
8169 SYSCALL(exec)
8170 SYSCALL(open)
8171 SYSCALL(mknod)
8172 SYSCALL(unlink)
8173 SYSCALL(fstat)
8174 SYSCALL(link)
8175 SYSCALL(mkdir)
8176 SYSCALL(chdir)
8177 SYSCALL(dup)
8178 SYSCALL(getpid)
8179 SYSCALL(sbrk)
8180 SYSCALL(sleep)
8181 SYSCALL(uptime)
8182 SYSCALL(setpriority)
8183 
8184 
8185 
8186 
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 
8201 
8202 #include "types.h"
8203 #include "stat.h"
8204 #include "user.h"
8205 #include "fcntl.h"
8206 
8207 char *argv[] = { "sh", 0 };
8208 
8209 int
8210 main(void)
8211 {
8212   int pid, wpid;
8213 
8214   if(open("console", O_RDWR) < 0){
8215     mknod("console", 1, 1);
8216     open("console", O_RDWR);
8217   }
8218   dup(0);  
8219   dup(0);  
8220 
8221   for(;;){
8222     printf(1, "init: starting sh\n");
8223     pid = fork();
8224     if(pid < 0){
8225       printf(1, "init: fork failed\n");
8226       exit();
8227     }
8228     if(pid == 0){
8229       exec("sh", argv);
8230       printf(1, "init: exec sh failed\n");
8231       exit();
8232     }
8233     while((wpid=wait()) >= 0 && wpid != pid)
8234       printf(1, "zombie!\n");
8235   }
8236 }
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 
8252 #include "types.h"
8253 #include "user.h"
8254 #include "fcntl.h"
8255 
8256 
8257 #define EXEC  1
8258 #define REDIR 2
8259 #define PIPE  3
8260 #define LIST  4
8261 #define BACK  5
8262 
8263 #define MAXARGS 10
8264 
8265 struct cmd {
8266   int type;
8267 };
8268 
8269 struct execcmd {
8270   int type;
8271   char *argv[MAXARGS];
8272   char *eargv[MAXARGS];
8273 };
8274 
8275 struct redircmd {
8276   int type;
8277   struct cmd *cmd;
8278   char *file;
8279   char *efile;
8280   int mode;
8281   int fd;
8282 };
8283 
8284 struct pipecmd {
8285   int type;
8286   struct cmd *left;
8287   struct cmd *right;
8288 };
8289 
8290 struct listcmd {
8291   int type;
8292   struct cmd *left;
8293   struct cmd *right;
8294 };
8295 
8296 struct backcmd {
8297   int type;
8298   struct cmd *cmd;
8299 };
8300 int fork1(void);  
8301 void panic(char*);
8302 struct cmd *parsecmd(char*);
8303 
8304 
8305 void
8306 runcmd(struct cmd *cmd)
8307 {
8308   int p[2];
8309   struct backcmd *bcmd;
8310   struct execcmd *ecmd;
8311   struct listcmd *lcmd;
8312   struct pipecmd *pcmd;
8313   struct redircmd *rcmd;
8314 
8315   if(cmd == 0)
8316     exit();
8317 
8318   switch(cmd->type){
8319   default:
8320     panic("runcmd");
8321 
8322   case EXEC:
8323     ecmd = (struct execcmd*)cmd;
8324     if(ecmd->argv[0] == 0)
8325       exit();
8326     exec(ecmd->argv[0], ecmd->argv);
8327     printf(2, "exec %s failed\n", ecmd->argv[0]);
8328     break;
8329 
8330   case REDIR:
8331     rcmd = (struct redircmd*)cmd;
8332     close(rcmd->fd);
8333     if(open(rcmd->file, rcmd->mode) < 0){
8334       printf(2, "open %s failed\n", rcmd->file);
8335       exit();
8336     }
8337     runcmd(rcmd->cmd);
8338     break;
8339 
8340   case LIST:
8341     lcmd = (struct listcmd*)cmd;
8342     if(fork1() == 0)
8343       runcmd(lcmd->left);
8344     wait();
8345     runcmd(lcmd->right);
8346     break;
8347 
8348 
8349 
8350   case PIPE:
8351     pcmd = (struct pipecmd*)cmd;
8352     if(pipe(p) < 0)
8353       panic("pipe");
8354     if(fork1() == 0){
8355       close(1);
8356       dup(p[1]);
8357       close(p[0]);
8358       close(p[1]);
8359       runcmd(pcmd->left);
8360     }
8361     if(fork1() == 0){
8362       close(0);
8363       dup(p[0]);
8364       close(p[0]);
8365       close(p[1]);
8366       runcmd(pcmd->right);
8367     }
8368     close(p[0]);
8369     close(p[1]);
8370     wait();
8371     wait();
8372     break;
8373 
8374   case BACK:
8375     bcmd = (struct backcmd*)cmd;
8376     if(fork1() == 0)
8377       runcmd(bcmd->cmd);
8378     break;
8379   }
8380   exit();
8381 }
8382 
8383 int
8384 getcmd(char *buf, int nbuf)
8385 {
8386   printf(2, "$ ");
8387   memset(buf, 0, nbuf);
8388   gets(buf, nbuf);
8389   if(buf[0] == 0) 
8390     return -1;
8391   return 0;
8392 }
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 int
8401 main(void)
8402 {
8403   static char buf[100];
8404   int fd;
8405 
8406   
8407   while((fd = open("console", O_RDWR)) >= 0){
8408     if(fd >= 3){
8409       close(fd);
8410       break;
8411     }
8412   }
8413 
8414   
8415   while(getcmd(buf, sizeof(buf)) >= 0){
8416     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8417       
8418       buf[strlen(buf)-1] = 0;  
8419       if(chdir(buf+3) < 0)
8420         printf(2, "cannot cd %s\n", buf+3);
8421       continue;
8422     }
8423     if(fork1() == 0)
8424       runcmd(parsecmd(buf));
8425     wait();
8426   }
8427   exit();
8428 }
8429 
8430 void
8431 panic(char *s)
8432 {
8433   printf(2, "%s\n", s);
8434   exit();
8435 }
8436 
8437 int
8438 fork1(void)
8439 {
8440   int pid;
8441 
8442   pid = fork();
8443   if(pid == -1)
8444     panic("fork");
8445   return pid;
8446 }
8447 
8448 
8449 
8450 
8451 
8452 struct cmd*
8453 execcmd(void)
8454 {
8455   struct execcmd *cmd;
8456 
8457   cmd = malloc(sizeof(*cmd));
8458   memset(cmd, 0, sizeof(*cmd));
8459   cmd->type = EXEC;
8460   return (struct cmd*)cmd;
8461 }
8462 
8463 struct cmd*
8464 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8465 {
8466   struct redircmd *cmd;
8467 
8468   cmd = malloc(sizeof(*cmd));
8469   memset(cmd, 0, sizeof(*cmd));
8470   cmd->type = REDIR;
8471   cmd->cmd = subcmd;
8472   cmd->file = file;
8473   cmd->efile = efile;
8474   cmd->mode = mode;
8475   cmd->fd = fd;
8476   return (struct cmd*)cmd;
8477 }
8478 
8479 struct cmd*
8480 pipecmd(struct cmd *left, struct cmd *right)
8481 {
8482   struct pipecmd *cmd;
8483 
8484   cmd = malloc(sizeof(*cmd));
8485   memset(cmd, 0, sizeof(*cmd));
8486   cmd->type = PIPE;
8487   cmd->left = left;
8488   cmd->right = right;
8489   return (struct cmd*)cmd;
8490 }
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 struct cmd*
8501 listcmd(struct cmd *left, struct cmd *right)
8502 {
8503   struct listcmd *cmd;
8504 
8505   cmd = malloc(sizeof(*cmd));
8506   memset(cmd, 0, sizeof(*cmd));
8507   cmd->type = LIST;
8508   cmd->left = left;
8509   cmd->right = right;
8510   return (struct cmd*)cmd;
8511 }
8512 
8513 struct cmd*
8514 backcmd(struct cmd *subcmd)
8515 {
8516   struct backcmd *cmd;
8517 
8518   cmd = malloc(sizeof(*cmd));
8519   memset(cmd, 0, sizeof(*cmd));
8520   cmd->type = BACK;
8521   cmd->cmd = subcmd;
8522   return (struct cmd*)cmd;
8523 }
8524 
8525 
8526 char whitespace[] = " \t\r\n\v";
8527 char symbols[] = "<|>&;()";
8528 
8529 int
8530 gettoken(char **ps, char *es, char **q, char **eq)
8531 {
8532   char *s;
8533   int ret;
8534 
8535   s = *ps;
8536   while(s < es && strchr(whitespace, *s))
8537     s++;
8538   if(q)
8539     *q = s;
8540   ret = *s;
8541   switch(*s){
8542   case 0:
8543     break;
8544   case '|':
8545   case '(':
8546   case ')':
8547   case ';':
8548   case '&':
8549   case '<':
8550     s++;
8551     break;
8552   case '>':
8553     s++;
8554     if(*s == '>'){
8555       ret = '+';
8556       s++;
8557     }
8558     break;
8559   default:
8560     ret = 'a';
8561     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8562       s++;
8563     break;
8564   }
8565   if(eq)
8566     *eq = s;
8567 
8568   while(s < es && strchr(whitespace, *s))
8569     s++;
8570   *ps = s;
8571   return ret;
8572 }
8573 
8574 int
8575 peek(char **ps, char *es, char *toks)
8576 {
8577   char *s;
8578 
8579   s = *ps;
8580   while(s < es && strchr(whitespace, *s))
8581     s++;
8582   *ps = s;
8583   return *s && strchr(toks, *s);
8584 }
8585 
8586 
8587 
8588 
8589 
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 struct cmd *parseline(char**, char*);
8601 struct cmd *parsepipe(char**, char*);
8602 struct cmd *parseexec(char**, char*);
8603 struct cmd *nulterminate(struct cmd*);
8604 
8605 struct cmd*
8606 parsecmd(char *s)
8607 {
8608   char *es;
8609   struct cmd *cmd;
8610 
8611   es = s + strlen(s);
8612   cmd = parseline(&s, es);
8613   peek(&s, es, "");
8614   if(s != es){
8615     printf(2, "leftovers: %s\n", s);
8616     panic("syntax");
8617   }
8618   nulterminate(cmd);
8619   return cmd;
8620 }
8621 
8622 struct cmd*
8623 parseline(char **ps, char *es)
8624 {
8625   struct cmd *cmd;
8626 
8627   cmd = parsepipe(ps, es);
8628   while(peek(ps, es, "&")){
8629     gettoken(ps, es, 0, 0);
8630     cmd = backcmd(cmd);
8631   }
8632   if(peek(ps, es, ";")){
8633     gettoken(ps, es, 0, 0);
8634     cmd = listcmd(cmd, parseline(ps, es));
8635   }
8636   return cmd;
8637 }
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 struct cmd*
8651 parsepipe(char **ps, char *es)
8652 {
8653   struct cmd *cmd;
8654 
8655   cmd = parseexec(ps, es);
8656   if(peek(ps, es, "|")){
8657     gettoken(ps, es, 0, 0);
8658     cmd = pipecmd(cmd, parsepipe(ps, es));
8659   }
8660   return cmd;
8661 }
8662 
8663 struct cmd*
8664 parseredirs(struct cmd *cmd, char **ps, char *es)
8665 {
8666   int tok;
8667   char *q, *eq;
8668 
8669   while(peek(ps, es, "<>")){
8670     tok = gettoken(ps, es, 0, 0);
8671     if(gettoken(ps, es, &q, &eq) != 'a')
8672       panic("missing file for redirection");
8673     switch(tok){
8674     case '<':
8675       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8676       break;
8677     case '>':
8678       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8679       break;
8680     case '+':  
8681       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8682       break;
8683     }
8684   }
8685   return cmd;
8686 }
8687 
8688 
8689 
8690 
8691 
8692 
8693 
8694 
8695 
8696 
8697 
8698 
8699 
8700 struct cmd*
8701 parseblock(char **ps, char *es)
8702 {
8703   struct cmd *cmd;
8704 
8705   if(!peek(ps, es, "("))
8706     panic("parseblock");
8707   gettoken(ps, es, 0, 0);
8708   cmd = parseline(ps, es);
8709   if(!peek(ps, es, ")"))
8710     panic("syntax - missing )");
8711   gettoken(ps, es, 0, 0);
8712   cmd = parseredirs(cmd, ps, es);
8713   return cmd;
8714 }
8715 
8716 struct cmd*
8717 parseexec(char **ps, char *es)
8718 {
8719   char *q, *eq;
8720   int tok, argc;
8721   struct execcmd *cmd;
8722   struct cmd *ret;
8723 
8724   if(peek(ps, es, "("))
8725     return parseblock(ps, es);
8726 
8727   ret = execcmd();
8728   cmd = (struct execcmd*)ret;
8729 
8730   argc = 0;
8731   ret = parseredirs(ret, ps, es);
8732   while(!peek(ps, es, "|)&;")){
8733     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8734       break;
8735     if(tok != 'a')
8736       panic("syntax");
8737     cmd->argv[argc] = q;
8738     cmd->eargv[argc] = eq;
8739     argc++;
8740     if(argc >= MAXARGS)
8741       panic("too many args");
8742     ret = parseredirs(ret, ps, es);
8743   }
8744   cmd->argv[argc] = 0;
8745   cmd->eargv[argc] = 0;
8746   return ret;
8747 }
8748 
8749 
8750 
8751 struct cmd*
8752 nulterminate(struct cmd *cmd)
8753 {
8754   int i;
8755   struct backcmd *bcmd;
8756   struct execcmd *ecmd;
8757   struct listcmd *lcmd;
8758   struct pipecmd *pcmd;
8759   struct redircmd *rcmd;
8760 
8761   if(cmd == 0)
8762     return 0;
8763 
8764   switch(cmd->type){
8765   case EXEC:
8766     ecmd = (struct execcmd*)cmd;
8767     for(i=0; ecmd->argv[i]; i++)
8768       *ecmd->eargv[i] = 0;
8769     break;
8770 
8771   case REDIR:
8772     rcmd = (struct redircmd*)cmd;
8773     nulterminate(rcmd->cmd);
8774     *rcmd->efile = 0;
8775     break;
8776 
8777   case PIPE:
8778     pcmd = (struct pipecmd*)cmd;
8779     nulterminate(pcmd->left);
8780     nulterminate(pcmd->right);
8781     break;
8782 
8783   case LIST:
8784     lcmd = (struct listcmd*)cmd;
8785     nulterminate(lcmd->left);
8786     nulterminate(lcmd->right);
8787     break;
8788 
8789   case BACK:
8790     bcmd = (struct backcmd*)cmd;
8791     nulterminate(bcmd->cmd);
8792     break;
8793   }
8794   return cmd;
8795 }
8796 
8797 
8798 
8799 
8800 
8801 
8802 
8803 
8804 
8805 
8806 
8807 
8808 
8809 .code16                       
8810 .globl start
8811 start:
8812   cli                         
8813 
8814   
8815   xorw    %ax,%ax             
8816   movw    %ax,%ds             
8817   movw    %ax,%es             
8818   movw    %ax,%ss             
8819 
8820   
8821   
8822 seta20.1:
8823   inb     $0x64,%al               
8824   testb   $0x2,%al
8825   jnz     seta20.1
8826 
8827   movb    $0xd1,%al               
8828   outb    %al,$0x64
8829 
8830 seta20.2:
8831   inb     $0x64,%al               
8832   testb   $0x2,%al
8833   jnz     seta20.2
8834 
8835   movb    $0xdf,%al               
8836   outb    %al,$0x60
8837 
8838   
8839   
8840   
8841   lgdt    gdtdesc
8842   movl    %cr0, %eax
8843   orl     $CR0_PE, %eax
8844   movl    %eax, %cr0
8845 
8846   
8847   
8848   
8849   ljmp    $(SEG_KCODE<<3), $start32
8850 .code32  
8851 start32:
8852   
8853   movw    $(SEG_KDATA<<3), %ax    
8854   movw    %ax, %ds                
8855   movw    %ax, %es                
8856   movw    %ax, %ss                
8857   movw    $0, %ax                 
8858   movw    %ax, %fs                
8859   movw    %ax, %gs                
8860 
8861   
8862   movl    $start, %esp
8863   call    bootmain
8864 
8865   
8866   
8867   movw    $0x8a00, %ax            
8868   movw    %ax, %dx
8869   outw    %ax, %dx
8870   movw    $0x8ae0, %ax            
8871   outw    %ax, %dx
8872 spin:
8873   jmp     spin
8874 
8875 
8876 .p2align 2                                
8877 gdt:
8878   SEG_NULLASM                             
8879   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
8880   SEG_ASM(STA_W, 0x0, 0xffffffff)         
8881 
8882 gdtdesc:
8883   .word   (gdtdesc - gdt - 1)             
8884   .long   gdt                             
8885 
8886 
8887 
8888 
8889 
8890 
8891 
8892 
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 
8901 
8902 
8903 
8904 
8905 
8906 
8907 #include "types.h"
8908 #include "elf.h"
8909 #include "x86.h"
8910 #include "memlayout.h"
8911 
8912 #define SECTSIZE  512
8913 
8914 void readseg(uchar*, uint, uint);
8915 
8916 void
8917 bootmain(void)
8918 {
8919   struct elfhdr *elf;
8920   struct proghdr *ph, *eph;
8921   void (*entry)(void);
8922   uchar* pa;
8923 
8924   elf = (struct elfhdr*)0x10000;  
8925 
8926   
8927   readseg((uchar*)elf, 4096, 0);
8928 
8929   
8930   if(elf->magic != ELF_MAGIC)
8931     return;  
8932 
8933   
8934   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
8935   eph = ph + elf->phnum;
8936   for(; ph < eph; ph++){
8937     pa = (uchar*)ph->paddr;
8938     readseg(pa, ph->filesz, ph->off);
8939     if(ph->memsz > ph->filesz)
8940       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
8941   }
8942 
8943   
8944   
8945   entry = (void(*)(void))(elf->entry);
8946   entry();
8947 }
8948 
8949 
8950 void
8951 waitdisk(void)
8952 {
8953   
8954   while((inb(0x1F7) & 0xC0) != 0x40)
8955     ;
8956 }
8957 
8958 
8959 void
8960 readsect(void *dst, uint offset)
8961 {
8962   
8963   waitdisk();
8964   outb(0x1F2, 1);   
8965   outb(0x1F3, offset);
8966   outb(0x1F4, offset >> 8);
8967   outb(0x1F5, offset >> 16);
8968   outb(0x1F6, (offset >> 24) | 0xE0);
8969   outb(0x1F7, 0x20);  
8970 
8971   
8972   waitdisk();
8973   insl(0x1F0, dst, SECTSIZE/4);
8974 }
8975 
8976 
8977 
8978 void
8979 readseg(uchar* pa, uint count, uint offset)
8980 {
8981   uchar* epa;
8982 
8983   epa = pa + count;
8984 
8985   
8986   pa -= offset % SECTSIZE;
8987 
8988   
8989   offset = (offset / SECTSIZE) + 1;
8990 
8991   
8992   
8993   
8994   for(; pa < epa; pa += SECTSIZE, offset++)
8995     readsect(pa, offset);
8996 }
8997 
8998 
8999 
9000 /* Simple linker script for the JOS kernel.
9001    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
9002 
9003 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
9004 OUTPUT_ARCH(i386)
9005 ENTRY(_start)
9006 
9007 SECTIONS
9008 {
9009 	/* Link the kernel at this address: "." means the current address */
9010         /* Must be equal to KERNLINK */
9011 	. = 0x80100000;
9012 
9013 	.text : AT(0x100000) {
9014 		*(.text .stub .text.* .gnu.linkonce.t.*)
9015 	}
9016 
9017 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
9018 
9019 	.rodata : {
9020 		*(.rodata .rodata.* .gnu.linkonce.r.*)
9021 	}
9022 
9023 	/* Include debugging information in kernel memory */
9024 	.stab : {
9025 		PROVIDE(__STAB_BEGIN__ = .);
9026 		*(.stab);
9027 		PROVIDE(__STAB_END__ = .);
9028 		BYTE(0)		/* Force the linker to allocate space
9029 				   for this section */
9030 	}
9031 
9032 	.stabstr : {
9033 		PROVIDE(__STABSTR_BEGIN__ = .);
9034 		*(.stabstr);
9035 		PROVIDE(__STABSTR_END__ = .);
9036 		BYTE(0)		/* Force the linker to allocate space
9037 				   for this section */
9038 	}
9039 
9040 	/* Adjust the address for the data segment to the next page */
9041 	. = ALIGN(0x1000);
9042 
9043 	/* Conventionally, Unix linkers provide pseudo-symbols
9044 	 * etext, edata, and end, at the end of the text, data, and bss.
9045 	 * For the kernel mapping, we need the address at the beginning
9046 	 * of the data section, but that's not one of the conventional
9047 	 * symbols, because the convention started before there was a
9048 	 * read-only rodata section between text and data. */
9049 	PROVIDE(data = .);
9050 	/* The data segment */
9051 	.data : {
9052 		*(.data)
9053 	}
9054 
9055 	PROVIDE(edata = .);
9056 
9057 	.bss : {
9058 		*(.bss)
9059 	}
9060 
9061 	PROVIDE(end = .);
9062 
9063 	/DISCARD/ : {
9064 		*(.eh_frame .note.GNU-stack)
9065 	}
9066 }
9067 
9068 
9069 
9070 
9071 
9072 
9073 
9074 
9075 
9076 
9077 
9078 
9079 
9080 
9081 
9082 
9083 
9084 
9085 
9086 
9087 
9088 
9089 
9090 
9091 
9092 
9093 
9094 
9095 
9096 
9097 
9098 
9099 
